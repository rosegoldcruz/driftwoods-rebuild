"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/lenis";
exports.ids = ["vendor-chunks/lenis"];
exports.modules = {

/***/ "(ssr)/./node_modules/lenis/dist/lenis.mjs":
/*!*******************************************!*\
  !*** ./node_modules/lenis/dist/lenis.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Lenis)\n/* harmony export */ });\n// package.json\nvar version = \"1.3.16\";\n// packages/core/src/maths.ts\nfunction clamp(min, input, max) {\n    return Math.max(min, Math.min(input, max));\n}\nfunction lerp(x, y, t) {\n    return (1 - t) * x + t * y;\n}\nfunction damp(x, y, lambda, deltaTime) {\n    return lerp(x, y, 1 - Math.exp(-lambda * deltaTime));\n}\nfunction modulo(n, d) {\n    return (n % d + d) % d;\n}\n// packages/core/src/animate.ts\nvar Animate = class {\n    /**\n   * Advance the animation by the given delta time\n   *\n   * @param deltaTime - The time in seconds to advance the animation\n   */ advance(deltaTime) {\n        if (!this.isRunning) return;\n        let completed = false;\n        if (this.duration && this.easing) {\n            this.currentTime += deltaTime;\n            const linearProgress = clamp(0, this.currentTime / this.duration, 1);\n            completed = linearProgress >= 1;\n            const easedProgress = completed ? 1 : this.easing(linearProgress);\n            this.value = this.from + (this.to - this.from) * easedProgress;\n        } else if (this.lerp) {\n            this.value = damp(this.value, this.to, this.lerp * 60, deltaTime);\n            if (Math.round(this.value) === this.to) {\n                this.value = this.to;\n                completed = true;\n            }\n        } else {\n            this.value = this.to;\n            completed = true;\n        }\n        if (completed) {\n            this.stop();\n        }\n        this.onUpdate?.(this.value, completed);\n    }\n    /** Stop the animation */ stop() {\n        this.isRunning = false;\n    }\n    /**\n   * Set up the animation from a starting value to an ending value\n   * with optional parameters for lerping, duration, easing, and onUpdate callback\n   *\n   * @param from - The starting value\n   * @param to - The ending value\n   * @param options - Options for the animation\n   */ fromTo(from, to, { lerp: lerp2, duration, easing, onStart, onUpdate }) {\n        this.from = this.value = from;\n        this.to = to;\n        this.lerp = lerp2;\n        this.duration = duration;\n        this.easing = easing;\n        this.currentTime = 0;\n        this.isRunning = true;\n        onStart?.();\n        this.onUpdate = onUpdate;\n    }\n    constructor(){\n        this.isRunning = false;\n        this.value = 0;\n        this.from = 0;\n        this.to = 0;\n        this.currentTime = 0;\n    }\n};\n// packages/core/src/debounce.ts\nfunction debounce(callback, delay) {\n    let timer;\n    return function(...args) {\n        let context = this;\n        clearTimeout(timer);\n        timer = setTimeout(()=>{\n            timer = void 0;\n            callback.apply(context, args);\n        }, delay);\n    };\n}\n// packages/core/src/dimensions.ts\nvar Dimensions = class {\n    constructor(wrapper, content, { autoResize = true, debounce: debounceValue = 250 } = {}){\n        this.width = 0;\n        this.height = 0;\n        this.scrollHeight = 0;\n        this.scrollWidth = 0;\n        this.resize = ()=>{\n            this.onWrapperResize();\n            this.onContentResize();\n        };\n        this.onWrapperResize = ()=>{\n            if (this.wrapper instanceof Window) {\n                this.width = window.innerWidth;\n                this.height = window.innerHeight;\n            } else {\n                this.width = this.wrapper.clientWidth;\n                this.height = this.wrapper.clientHeight;\n            }\n        };\n        this.onContentResize = ()=>{\n            if (this.wrapper instanceof Window) {\n                this.scrollHeight = this.content.scrollHeight;\n                this.scrollWidth = this.content.scrollWidth;\n            } else {\n                this.scrollHeight = this.wrapper.scrollHeight;\n                this.scrollWidth = this.wrapper.scrollWidth;\n            }\n        };\n        this.wrapper = wrapper;\n        this.content = content;\n        if (autoResize) {\n            this.debouncedResize = debounce(this.resize, debounceValue);\n            if (this.wrapper instanceof Window) {\n                window.addEventListener(\"resize\", this.debouncedResize, false);\n            } else {\n                this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize);\n                this.wrapperResizeObserver.observe(this.wrapper);\n            }\n            this.contentResizeObserver = new ResizeObserver(this.debouncedResize);\n            this.contentResizeObserver.observe(this.content);\n        }\n        this.resize();\n    }\n    destroy() {\n        this.wrapperResizeObserver?.disconnect();\n        this.contentResizeObserver?.disconnect();\n        if (this.wrapper === window && this.debouncedResize) {\n            window.removeEventListener(\"resize\", this.debouncedResize, false);\n        }\n    }\n    get limit() {\n        return {\n            x: this.scrollWidth - this.width,\n            y: this.scrollHeight - this.height\n        };\n    }\n};\n// packages/core/src/emitter.ts\nvar Emitter = class {\n    /**\n   * Emit an event with the given data\n   * @param event Event name\n   * @param args Data to pass to the event handlers\n   */ emit(event, ...args) {\n        let callbacks = this.events[event] || [];\n        for(let i = 0, length = callbacks.length; i < length; i++){\n            callbacks[i]?.(...args);\n        }\n    }\n    /**\n   * Add a callback to the event\n   * @param event Event name\n   * @param cb Callback function\n   * @returns Unsubscribe function\n   */ on(event, cb) {\n        this.events[event]?.push(cb) || (this.events[event] = [\n            cb\n        ]);\n        return ()=>{\n            this.events[event] = this.events[event]?.filter((i)=>cb !== i);\n        };\n    }\n    /**\n   * Remove a callback from the event\n   * @param event Event name\n   * @param callback Callback function\n   */ off(event, callback) {\n        this.events[event] = this.events[event]?.filter((i)=>callback !== i);\n    }\n    /**\n   * Remove all event listeners and clean up\n   */ destroy() {\n        this.events = {};\n    }\n    constructor(){\n        this.events = {};\n    }\n};\n// packages/core/src/virtual-scroll.ts\nvar LINE_HEIGHT = 100 / 6;\nvar listenerOptions = {\n    passive: false\n};\nvar VirtualScroll = class {\n    constructor(element, options = {\n        wheelMultiplier: 1,\n        touchMultiplier: 1\n    }){\n        this.touchStart = {\n            x: 0,\n            y: 0\n        };\n        this.lastDelta = {\n            x: 0,\n            y: 0\n        };\n        this.window = {\n            width: 0,\n            height: 0\n        };\n        this.emitter = new Emitter();\n        /**\n   * Event handler for 'touchstart' event\n   *\n   * @param event Touch event\n   */ this.onTouchStart = (event)=>{\n            const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n            this.touchStart.x = clientX;\n            this.touchStart.y = clientY;\n            this.lastDelta = {\n                x: 0,\n                y: 0\n            };\n            this.emitter.emit(\"scroll\", {\n                deltaX: 0,\n                deltaY: 0,\n                event\n            });\n        };\n        /** Event handler for 'touchmove' event */ this.onTouchMove = (event)=>{\n            const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n            const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier;\n            const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier;\n            this.touchStart.x = clientX;\n            this.touchStart.y = clientY;\n            this.lastDelta = {\n                x: deltaX,\n                y: deltaY\n            };\n            this.emitter.emit(\"scroll\", {\n                deltaX,\n                deltaY,\n                event\n            });\n        };\n        this.onTouchEnd = (event)=>{\n            this.emitter.emit(\"scroll\", {\n                deltaX: this.lastDelta.x,\n                deltaY: this.lastDelta.y,\n                event\n            });\n        };\n        /** Event handler for 'wheel' event */ this.onWheel = (event)=>{\n            let { deltaX, deltaY, deltaMode } = event;\n            const multiplierX = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1;\n            const multiplierY = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1;\n            deltaX *= multiplierX;\n            deltaY *= multiplierY;\n            deltaX *= this.options.wheelMultiplier;\n            deltaY *= this.options.wheelMultiplier;\n            this.emitter.emit(\"scroll\", {\n                deltaX,\n                deltaY,\n                event\n            });\n        };\n        this.onWindowResize = ()=>{\n            this.window = {\n                width: window.innerWidth,\n                height: window.innerHeight\n            };\n        };\n        this.element = element;\n        this.options = options;\n        window.addEventListener(\"resize\", this.onWindowResize, false);\n        this.onWindowResize();\n        this.element.addEventListener(\"wheel\", this.onWheel, listenerOptions);\n        this.element.addEventListener(\"touchstart\", this.onTouchStart, listenerOptions);\n        this.element.addEventListener(\"touchmove\", this.onTouchMove, listenerOptions);\n        this.element.addEventListener(\"touchend\", this.onTouchEnd, listenerOptions);\n    }\n    /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */ on(event, callback) {\n        return this.emitter.on(event, callback);\n    }\n    /** Remove all event listeners and clean up */ destroy() {\n        this.emitter.destroy();\n        window.removeEventListener(\"resize\", this.onWindowResize, false);\n        this.element.removeEventListener(\"wheel\", this.onWheel, listenerOptions);\n        this.element.removeEventListener(\"touchstart\", this.onTouchStart, listenerOptions);\n        this.element.removeEventListener(\"touchmove\", this.onTouchMove, listenerOptions);\n        this.element.removeEventListener(\"touchend\", this.onTouchEnd, listenerOptions);\n    }\n};\n// packages/core/src/lenis.ts\nvar defaultEasing = (t)=>Math.min(1, 1.001 - Math.pow(2, -10 * t));\nvar Lenis = class {\n    constructor({ wrapper = window, content = document.documentElement, eventsTarget = wrapper, smoothWheel = true, syncTouch = false, syncTouchLerp = 0.075, touchInertiaExponent = 1.7, duration, // in seconds\n    easing, lerp: lerp2 = 0.1, infinite = false, orientation = \"vertical\", // vertical, horizontal\n    gestureOrientation = orientation === \"horizontal\" ? \"both\" : \"vertical\", // vertical, horizontal, both\n    touchMultiplier = 1, wheelMultiplier = 1, autoResize = true, prevent, virtualScroll, overscroll = true, autoRaf = false, anchors = false, autoToggle = false, // https://caniuse.com/?search=transition-behavior\n    allowNestedScroll = false, __experimental__naiveDimensions = false } = {}){\n        this._isScrolling = false;\n        // true when scroll is animating\n        this._isStopped = false;\n        // true if user should not be able to scroll - enable/disable programmatically\n        this._isLocked = false;\n        // same as isStopped but enabled/disabled when scroll reaches target\n        this._preventNextNativeScrollEvent = false;\n        this._resetVelocityTimeout = null;\n        this.__rafID = null;\n        /**\n   * The time in ms since the lenis instance was created\n   */ this.time = 0;\n        /**\n   * User data that will be forwarded through the scroll event\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   userData: {\n   *     foo: 'bar'\n   *   }\n   * })\n   */ this.userData = {};\n        /**\n   * The last velocity of the scroll\n   */ this.lastVelocity = 0;\n        /**\n   * The current velocity of the scroll\n   */ this.velocity = 0;\n        /**\n   * The direction of the scroll\n   */ this.direction = 0;\n        // These are instanciated here as they don't need information from the options\n        this.animate = new Animate();\n        this.emitter = new Emitter();\n        this.onScrollEnd = (e)=>{\n            if (!(e instanceof CustomEvent)) {\n                if (this.isScrolling === \"smooth\" || this.isScrolling === false) {\n                    e.stopPropagation();\n                }\n            }\n        };\n        this.dispatchScrollendEvent = ()=>{\n            this.options.wrapper.dispatchEvent(new CustomEvent(\"scrollend\", {\n                bubbles: this.options.wrapper === window,\n                // cancelable: false,\n                detail: {\n                    lenisScrollEnd: true\n                }\n            }));\n        };\n        this.onTransitionEnd = (event)=>{\n            if (event.propertyName.includes(\"overflow\")) {\n                this.checkOverflow();\n            }\n        };\n        this.onClick = (event)=>{\n            const path = event.composedPath();\n            const anchor = path.find((node)=>node instanceof HTMLAnchorElement && node.getAttribute(\"href\")?.includes(\"#\"));\n            if (anchor) {\n                const href = anchor.getAttribute(\"href\");\n                if (href) {\n                    const options = typeof this.options.anchors === \"object\" && this.options.anchors ? this.options.anchors : void 0;\n                    const target = `#${href.split(\"#\")[1]}`;\n                    this.scrollTo(target, options);\n                }\n            }\n        };\n        this.onPointerDown = (event)=>{\n            if (event.button === 1) {\n                this.reset();\n            }\n        };\n        this.onVirtualScroll = (data)=>{\n            if (typeof this.options.virtualScroll === \"function\" && this.options.virtualScroll(data) === false) return;\n            const { deltaX, deltaY, event } = data;\n            this.emitter.emit(\"virtual-scroll\", {\n                deltaX,\n                deltaY,\n                event\n            });\n            if (event.ctrlKey) return;\n            if (event.lenisStopPropagation) return;\n            const isTouch = event.type.includes(\"touch\");\n            const isWheel = event.type.includes(\"wheel\");\n            this.isTouching = event.type === \"touchstart\" || event.type === \"touchmove\";\n            const isClickOrTap = deltaX === 0 && deltaY === 0;\n            const isTapToStop = this.options.syncTouch && isTouch && event.type === \"touchstart\" && isClickOrTap && !this.isStopped && !this.isLocked;\n            if (isTapToStop) {\n                this.reset();\n                return;\n            }\n            const isUnknownGesture = this.options.gestureOrientation === \"vertical\" && deltaY === 0 || this.options.gestureOrientation === \"horizontal\" && deltaX === 0;\n            if (isClickOrTap || isUnknownGesture) {\n                return;\n            }\n            let composedPath = event.composedPath();\n            composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement));\n            const prevent = this.options.prevent;\n            if (!!composedPath.find((node)=>node instanceof HTMLElement && (typeof prevent === \"function\" && prevent?.(node) || node.hasAttribute?.(\"data-lenis-prevent\") || isTouch && node.hasAttribute?.(\"data-lenis-prevent-touch\") || isWheel && node.hasAttribute?.(\"data-lenis-prevent-wheel\") || this.options.allowNestedScroll && this.checkNestedScroll(node, {\n                    deltaX,\n                    deltaY\n                })))) return;\n            if (this.isStopped || this.isLocked) {\n                if (event.cancelable) {\n                    event.preventDefault();\n                }\n                return;\n            }\n            const isSmooth = this.options.syncTouch && isTouch || this.options.smoothWheel && isWheel;\n            if (!isSmooth) {\n                this.isScrolling = \"native\";\n                this.animate.stop();\n                event.lenisStopPropagation = true;\n                return;\n            }\n            let delta = deltaY;\n            if (this.options.gestureOrientation === \"both\") {\n                delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX;\n            } else if (this.options.gestureOrientation === \"horizontal\") {\n                delta = deltaX;\n            }\n            if (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && this.limit > 0 && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && deltaY > 0 || this.animatedScroll === this.limit && deltaY < 0)) {\n                event.lenisStopPropagation = true;\n            }\n            if (event.cancelable) {\n                event.preventDefault();\n            }\n            const isSyncTouch = isTouch && this.options.syncTouch;\n            const isTouchEnd = isTouch && event.type === \"touchend\";\n            const hasTouchInertia = isTouchEnd;\n            if (hasTouchInertia) {\n                delta = Math.sign(this.velocity) * Math.pow(Math.abs(this.velocity), this.options.touchInertiaExponent);\n            }\n            this.scrollTo(this.targetScroll + delta, {\n                programmatic: false,\n                ...isSyncTouch ? {\n                    lerp: hasTouchInertia ? this.options.syncTouchLerp : 1\n                } : {\n                    lerp: this.options.lerp,\n                    duration: this.options.duration,\n                    easing: this.options.easing\n                }\n            });\n        };\n        this.onNativeScroll = ()=>{\n            if (this._resetVelocityTimeout !== null) {\n                clearTimeout(this._resetVelocityTimeout);\n                this._resetVelocityTimeout = null;\n            }\n            if (this._preventNextNativeScrollEvent) {\n                this._preventNextNativeScrollEvent = false;\n                return;\n            }\n            if (this.isScrolling === false || this.isScrolling === \"native\") {\n                const lastScroll = this.animatedScroll;\n                this.animatedScroll = this.targetScroll = this.actualScroll;\n                this.lastVelocity = this.velocity;\n                this.velocity = this.animatedScroll - lastScroll;\n                this.direction = Math.sign(this.animatedScroll - lastScroll);\n                if (!this.isStopped) {\n                    this.isScrolling = \"native\";\n                }\n                this.emit();\n                if (this.velocity !== 0) {\n                    this._resetVelocityTimeout = setTimeout(()=>{\n                        this.lastVelocity = this.velocity;\n                        this.velocity = 0;\n                        this.isScrolling = false;\n                        this.emit();\n                    }, 400);\n                }\n            }\n        };\n        /**\n   * RequestAnimationFrame for lenis\n   *\n   * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus\n   */ this.raf = (time)=>{\n            const deltaTime = time - (this.time || time);\n            this.time = time;\n            this.animate.advance(deltaTime * 1e-3);\n            if (this.options.autoRaf) {\n                this.__rafID = requestAnimationFrame(this.raf);\n            }\n        };\n        window.lenisVersion = version;\n        if (!wrapper || wrapper === document.documentElement) {\n            wrapper = window;\n        }\n        if (typeof duration === \"number\" && typeof easing !== \"function\") {\n            easing = defaultEasing;\n        } else if (typeof easing === \"function\" && typeof duration !== \"number\") {\n            duration = 1;\n        }\n        this.options = {\n            wrapper,\n            content,\n            eventsTarget,\n            smoothWheel,\n            syncTouch,\n            syncTouchLerp,\n            touchInertiaExponent,\n            duration,\n            easing,\n            lerp: lerp2,\n            infinite,\n            gestureOrientation,\n            orientation,\n            touchMultiplier,\n            wheelMultiplier,\n            autoResize,\n            prevent,\n            virtualScroll,\n            overscroll,\n            autoRaf,\n            anchors,\n            autoToggle,\n            allowNestedScroll,\n            __experimental__naiveDimensions\n        };\n        this.dimensions = new Dimensions(wrapper, content, {\n            autoResize\n        });\n        this.updateClassName();\n        this.targetScroll = this.animatedScroll = this.actualScroll;\n        this.options.wrapper.addEventListener(\"scroll\", this.onNativeScroll, false);\n        this.options.wrapper.addEventListener(\"scrollend\", this.onScrollEnd, {\n            capture: true\n        });\n        if (this.options.anchors && this.options.wrapper === window) {\n            this.options.wrapper.addEventListener(\"click\", this.onClick, false);\n        }\n        this.options.wrapper.addEventListener(\"pointerdown\", this.onPointerDown, false);\n        this.virtualScroll = new VirtualScroll(eventsTarget, {\n            touchMultiplier,\n            wheelMultiplier\n        });\n        this.virtualScroll.on(\"scroll\", this.onVirtualScroll);\n        if (this.options.autoToggle) {\n            this.checkOverflow();\n            this.rootElement.addEventListener(\"transitionend\", this.onTransitionEnd, {\n                passive: true\n            });\n        }\n        if (this.options.autoRaf) {\n            this.__rafID = requestAnimationFrame(this.raf);\n        }\n    }\n    /**\n   * Destroy the lenis instance, remove all event listeners and clean up the class name\n   */ destroy() {\n        this.emitter.destroy();\n        this.options.wrapper.removeEventListener(\"scroll\", this.onNativeScroll, false);\n        this.options.wrapper.removeEventListener(\"scrollend\", this.onScrollEnd, {\n            capture: true\n        });\n        this.options.wrapper.removeEventListener(\"pointerdown\", this.onPointerDown, false);\n        if (this.options.anchors && this.options.wrapper === window) {\n            this.options.wrapper.removeEventListener(\"click\", this.onClick, false);\n        }\n        this.virtualScroll.destroy();\n        this.dimensions.destroy();\n        this.cleanUpClassName();\n        if (this.__rafID) {\n            cancelAnimationFrame(this.__rafID);\n        }\n    }\n    on(event, callback) {\n        return this.emitter.on(event, callback);\n    }\n    off(event, callback) {\n        return this.emitter.off(event, callback);\n    }\n    get overflow() {\n        const property = this.isHorizontal ? \"overflow-x\" : \"overflow-y\";\n        return getComputedStyle(this.rootElement)[property];\n    }\n    checkOverflow() {\n        if ([\n            \"hidden\",\n            \"clip\"\n        ].includes(this.overflow)) {\n            this.internalStop();\n        } else {\n            this.internalStart();\n        }\n    }\n    setScroll(scroll) {\n        if (this.isHorizontal) {\n            this.options.wrapper.scrollTo({\n                left: scroll,\n                behavior: \"instant\"\n            });\n        } else {\n            this.options.wrapper.scrollTo({\n                top: scroll,\n                behavior: \"instant\"\n            });\n        }\n    }\n    /**\n   * Force lenis to recalculate the dimensions\n   */ resize() {\n        this.dimensions.resize();\n        this.animatedScroll = this.targetScroll = this.actualScroll;\n        this.emit();\n    }\n    emit() {\n        this.emitter.emit(\"scroll\", this);\n    }\n    reset() {\n        this.isLocked = false;\n        this.isScrolling = false;\n        this.animatedScroll = this.targetScroll = this.actualScroll;\n        this.lastVelocity = this.velocity = 0;\n        this.animate.stop();\n    }\n    /**\n   * Start lenis scroll after it has been stopped\n   */ start() {\n        if (!this.isStopped) return;\n        if (this.options.autoToggle) {\n            this.rootElement.style.removeProperty(\"overflow\");\n            return;\n        }\n        this.internalStart();\n    }\n    internalStart() {\n        if (!this.isStopped) return;\n        this.reset();\n        this.isStopped = false;\n        this.emit();\n    }\n    /**\n   * Stop lenis scroll\n   */ stop() {\n        if (this.isStopped) return;\n        if (this.options.autoToggle) {\n            this.rootElement.style.setProperty(\"overflow\", \"clip\");\n            return;\n        }\n        this.internalStop();\n    }\n    internalStop() {\n        if (this.isStopped) return;\n        this.reset();\n        this.isStopped = true;\n        this.emit();\n    }\n    /**\n   * Scroll to a target value\n   *\n   * @param target The target value to scroll to\n   * @param options The options for the scroll\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   offset: 100,\n   *   duration: 1,\n   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),\n   *   lerp: 0.1,\n   *   onStart: () => {\n   *     console.log('onStart')\n   *   },\n   *   onComplete: () => {\n   *     console.log('onComplete')\n   *   },\n   * })\n   */ scrollTo(target, { offset = 0, immediate = false, lock = false, duration = this.options.duration, easing = this.options.easing, lerp: lerp2 = this.options.lerp, onStart, onComplete, force = false, // scroll even if stopped\n    programmatic = true, // called from outside of the class\n    userData } = {}) {\n        if ((this.isStopped || this.isLocked) && !force) return;\n        if (typeof target === \"string\" && [\n            \"top\",\n            \"left\",\n            \"start\",\n            \"#\"\n        ].includes(target)) {\n            target = 0;\n        } else if (typeof target === \"string\" && [\n            \"bottom\",\n            \"right\",\n            \"end\"\n        ].includes(target)) {\n            target = this.limit;\n        } else {\n            let node;\n            if (typeof target === \"string\") {\n                node = document.querySelector(target);\n                if (!node) {\n                    if (target === \"#top\") {\n                        target = 0;\n                    } else {\n                        console.warn(\"Lenis: Target not found\", target);\n                    }\n                }\n            } else if (target instanceof HTMLElement && target?.nodeType) {\n                node = target;\n            }\n            if (node) {\n                if (this.options.wrapper !== window) {\n                    const wrapperRect = this.rootElement.getBoundingClientRect();\n                    offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top;\n                }\n                const rect = node.getBoundingClientRect();\n                target = (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll;\n            }\n        }\n        if (typeof target !== \"number\") return;\n        target += offset;\n        target = Math.round(target);\n        if (this.options.infinite) {\n            if (programmatic) {\n                this.targetScroll = this.animatedScroll = this.scroll;\n                const distance = target - this.animatedScroll;\n                if (distance > this.limit / 2) {\n                    target = target - this.limit;\n                } else if (distance < -this.limit / 2) {\n                    target = target + this.limit;\n                }\n            }\n        } else {\n            target = clamp(0, target, this.limit);\n        }\n        if (target === this.targetScroll) {\n            onStart?.(this);\n            onComplete?.(this);\n            return;\n        }\n        this.userData = userData ?? {};\n        if (immediate) {\n            this.animatedScroll = this.targetScroll = target;\n            this.setScroll(this.scroll);\n            this.reset();\n            this.preventNextNativeScrollEvent();\n            this.emit();\n            onComplete?.(this);\n            this.userData = {};\n            requestAnimationFrame(()=>{\n                this.dispatchScrollendEvent();\n            });\n            return;\n        }\n        if (!programmatic) {\n            this.targetScroll = target;\n        }\n        if (typeof duration === \"number\" && typeof easing !== \"function\") {\n            easing = defaultEasing;\n        } else if (typeof easing === \"function\" && typeof duration !== \"number\") {\n            duration = 1;\n        }\n        this.animate.fromTo(this.animatedScroll, target, {\n            duration,\n            easing,\n            lerp: lerp2,\n            onStart: ()=>{\n                if (lock) this.isLocked = true;\n                this.isScrolling = \"smooth\";\n                onStart?.(this);\n            },\n            onUpdate: (value, completed)=>{\n                this.isScrolling = \"smooth\";\n                this.lastVelocity = this.velocity;\n                this.velocity = value - this.animatedScroll;\n                this.direction = Math.sign(this.velocity);\n                this.animatedScroll = value;\n                this.setScroll(this.scroll);\n                if (programmatic) {\n                    this.targetScroll = value;\n                }\n                if (!completed) this.emit();\n                if (completed) {\n                    this.reset();\n                    this.emit();\n                    onComplete?.(this);\n                    this.userData = {};\n                    requestAnimationFrame(()=>{\n                        this.dispatchScrollendEvent();\n                    });\n                    this.preventNextNativeScrollEvent();\n                }\n            }\n        });\n    }\n    preventNextNativeScrollEvent() {\n        this._preventNextNativeScrollEvent = true;\n        requestAnimationFrame(()=>{\n            this._preventNextNativeScrollEvent = false;\n        });\n    }\n    checkNestedScroll(node, { deltaX, deltaY }) {\n        const time = Date.now();\n        const cache = node._lenis ??= {};\n        let hasOverflowX, hasOverflowY, isScrollableX, isScrollableY, scrollWidth, scrollHeight, clientWidth, clientHeight;\n        const gestureOrientation = this.options.gestureOrientation;\n        if (time - (cache.time ?? 0) > 2e3) {\n            cache.time = Date.now();\n            const computedStyle = window.getComputedStyle(node);\n            cache.computedStyle = computedStyle;\n            const overflowXString = computedStyle.overflowX;\n            const overflowYString = computedStyle.overflowY;\n            hasOverflowX = [\n                \"auto\",\n                \"overlay\",\n                \"scroll\"\n            ].includes(overflowXString);\n            hasOverflowY = [\n                \"auto\",\n                \"overlay\",\n                \"scroll\"\n            ].includes(overflowYString);\n            cache.hasOverflowX = hasOverflowX;\n            cache.hasOverflowY = hasOverflowY;\n            if (!hasOverflowX && !hasOverflowY) return false;\n            if (gestureOrientation === \"vertical\" && !hasOverflowY) return false;\n            if (gestureOrientation === \"horizontal\" && !hasOverflowX) return false;\n            scrollWidth = node.scrollWidth;\n            scrollHeight = node.scrollHeight;\n            clientWidth = node.clientWidth;\n            clientHeight = node.clientHeight;\n            isScrollableX = scrollWidth > clientWidth;\n            isScrollableY = scrollHeight > clientHeight;\n            cache.isScrollableX = isScrollableX;\n            cache.isScrollableY = isScrollableY;\n            cache.scrollWidth = scrollWidth;\n            cache.scrollHeight = scrollHeight;\n            cache.clientWidth = clientWidth;\n            cache.clientHeight = clientHeight;\n        } else {\n            isScrollableX = cache.isScrollableX;\n            isScrollableY = cache.isScrollableY;\n            hasOverflowX = cache.hasOverflowX;\n            hasOverflowY = cache.hasOverflowY;\n            scrollWidth = cache.scrollWidth;\n            scrollHeight = cache.scrollHeight;\n            clientWidth = cache.clientWidth;\n            clientHeight = cache.clientHeight;\n        }\n        if (!hasOverflowX && !hasOverflowY || !isScrollableX && !isScrollableY) {\n            return false;\n        }\n        if (gestureOrientation === \"vertical\" && (!hasOverflowY || !isScrollableY)) return false;\n        if (gestureOrientation === \"horizontal\" && (!hasOverflowX || !isScrollableX)) return false;\n        let orientation;\n        if (gestureOrientation === \"horizontal\") {\n            orientation = \"x\";\n        } else if (gestureOrientation === \"vertical\") {\n            orientation = \"y\";\n        } else {\n            const isScrollingX = deltaX !== 0;\n            const isScrollingY = deltaY !== 0;\n            if (isScrollingX && hasOverflowX && isScrollableX) {\n                orientation = \"x\";\n            }\n            if (isScrollingY && hasOverflowY && isScrollableY) {\n                orientation = \"y\";\n            }\n        }\n        if (!orientation) return false;\n        let scroll, maxScroll, delta, hasOverflow, isScrollable;\n        if (orientation === \"x\") {\n            scroll = node.scrollLeft;\n            maxScroll = scrollWidth - clientWidth;\n            delta = deltaX;\n            hasOverflow = hasOverflowX;\n            isScrollable = isScrollableX;\n        } else if (orientation === \"y\") {\n            scroll = node.scrollTop;\n            maxScroll = scrollHeight - clientHeight;\n            delta = deltaY;\n            hasOverflow = hasOverflowY;\n            isScrollable = isScrollableY;\n        } else {\n            return false;\n        }\n        const willScroll = delta > 0 ? scroll < maxScroll : scroll > 0;\n        return willScroll && hasOverflow && isScrollable;\n    }\n    /**\n   * The root element on which lenis is instanced\n   */ get rootElement() {\n        return this.options.wrapper === window ? document.documentElement : this.options.wrapper;\n    }\n    /**\n   * The limit which is the maximum scroll value\n   */ get limit() {\n        if (this.options.__experimental__naiveDimensions) {\n            if (this.isHorizontal) {\n                return this.rootElement.scrollWidth - this.rootElement.clientWidth;\n            } else {\n                return this.rootElement.scrollHeight - this.rootElement.clientHeight;\n            }\n        } else {\n            return this.dimensions.limit[this.isHorizontal ? \"x\" : \"y\"];\n        }\n    }\n    /**\n   * Whether or not the scroll is horizontal\n   */ get isHorizontal() {\n        return this.options.orientation === \"horizontal\";\n    }\n    /**\n   * The actual scroll value\n   */ get actualScroll() {\n        const wrapper = this.options.wrapper;\n        return this.isHorizontal ? wrapper.scrollX ?? wrapper.scrollLeft : wrapper.scrollY ?? wrapper.scrollTop;\n    }\n    /**\n   * The current scroll value\n   */ get scroll() {\n        return this.options.infinite ? modulo(this.animatedScroll, this.limit) : this.animatedScroll;\n    }\n    /**\n   * The progress of the scroll relative to the limit\n   */ get progress() {\n        return this.limit === 0 ? 1 : this.scroll / this.limit;\n    }\n    /**\n   * Current scroll state\n   */ get isScrolling() {\n        return this._isScrolling;\n    }\n    set isScrolling(value) {\n        if (this._isScrolling !== value) {\n            this._isScrolling = value;\n            this.updateClassName();\n        }\n    }\n    /**\n   * Check if lenis is stopped\n   */ get isStopped() {\n        return this._isStopped;\n    }\n    set isStopped(value) {\n        if (this._isStopped !== value) {\n            this._isStopped = value;\n            this.updateClassName();\n        }\n    }\n    /**\n   * Check if lenis is locked\n   */ get isLocked() {\n        return this._isLocked;\n    }\n    set isLocked(value) {\n        if (this._isLocked !== value) {\n            this._isLocked = value;\n            this.updateClassName();\n        }\n    }\n    /**\n   * Check if lenis is smooth scrolling\n   */ get isSmooth() {\n        return this.isScrolling === \"smooth\";\n    }\n    /**\n   * The class name applied to the wrapper element\n   */ get className() {\n        let className = \"lenis\";\n        if (this.options.autoToggle) className += \" lenis-autoToggle\";\n        if (this.isStopped) className += \" lenis-stopped\";\n        if (this.isLocked) className += \" lenis-locked\";\n        if (this.isScrolling) className += \" lenis-scrolling\";\n        if (this.isScrolling === \"smooth\") className += \" lenis-smooth\";\n        return className;\n    }\n    updateClassName() {\n        this.cleanUpClassName();\n        this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim();\n    }\n    cleanUpClassName() {\n        this.rootElement.className = this.rootElement.className.replace(/lenis(-\\w+)?/g, \"\").trim();\n    }\n};\n //# sourceMappingURL=lenis.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFJLENBQUN6QixXQUFXLENBQUNnRixTQUFTLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQ2hGLFdBQVcsQ0FBQ2dGLFNBQVMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDQSxTQUFTLENBQUMsQ0FBQyxDQUFDQyxJQUFJO0lBQ3JGO0lBQ0F4RCxtQkFBbUI7UUFDakIsSUFBSSxDQUFDekIsV0FBVyxDQUFDZ0YsU0FBUyxHQUFHLElBQUksQ0FBQ2hGLFdBQVcsQ0FBQ2dGLFNBQVMsQ0FBQ0UsT0FBTyxDQUFDLGlCQUFpQixJQUFJRCxJQUFJO0lBQzNGO0FBQ0Y7QUFHRSxDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2RyaWZ0d29vZHMtcmVidWlsZC8uL25vZGVfbW9kdWxlcy9sZW5pcy9kaXN0L2xlbmlzLm1qcz8xMjgzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHBhY2thZ2UuanNvblxudmFyIHZlcnNpb24gPSBcIjEuMy4xNlwiO1xuXG4vLyBwYWNrYWdlcy9jb3JlL3NyYy9tYXRocy50c1xuZnVuY3Rpb24gY2xhbXAobWluLCBpbnB1dCwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKGlucHV0LCBtYXgpKTtcbn1cbmZ1bmN0aW9uIGxlcnAoeCwgeSwgdCkge1xuICByZXR1cm4gKDEgLSB0KSAqIHggKyB0ICogeTtcbn1cbmZ1bmN0aW9uIGRhbXAoeCwgeSwgbGFtYmRhLCBkZWx0YVRpbWUpIHtcbiAgcmV0dXJuIGxlcnAoeCwgeSwgMSAtIE1hdGguZXhwKC1sYW1iZGEgKiBkZWx0YVRpbWUpKTtcbn1cbmZ1bmN0aW9uIG1vZHVsbyhuLCBkKSB7XG4gIHJldHVybiAobiAlIGQgKyBkKSAlIGQ7XG59XG5cbi8vIHBhY2thZ2VzL2NvcmUvc3JjL2FuaW1hdGUudHNcbnZhciBBbmltYXRlID0gY2xhc3Mge1xuICBpc1J1bm5pbmcgPSBmYWxzZTtcbiAgdmFsdWUgPSAwO1xuICBmcm9tID0gMDtcbiAgdG8gPSAwO1xuICBjdXJyZW50VGltZSA9IDA7XG4gIC8vIFRoZXNlIGFyZSBpbnN0YW5jaWF0ZWQgaW4gdGhlIGZyb21UbyBtZXRob2RcbiAgbGVycDtcbiAgZHVyYXRpb247XG4gIGVhc2luZztcbiAgb25VcGRhdGU7XG4gIC8qKlxuICAgKiBBZHZhbmNlIHRoZSBhbmltYXRpb24gYnkgdGhlIGdpdmVuIGRlbHRhIHRpbWVcbiAgICpcbiAgICogQHBhcmFtIGRlbHRhVGltZSAtIFRoZSB0aW1lIGluIHNlY29uZHMgdG8gYWR2YW5jZSB0aGUgYW5pbWF0aW9uXG4gICAqL1xuICBhZHZhbmNlKGRlbHRhVGltZSkge1xuICAgIGlmICghdGhpcy5pc1J1bm5pbmcpIHJldHVybjtcbiAgICBsZXQgY29tcGxldGVkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuZHVyYXRpb24gJiYgdGhpcy5lYXNpbmcpIHtcbiAgICAgIHRoaXMuY3VycmVudFRpbWUgKz0gZGVsdGFUaW1lO1xuICAgICAgY29uc3QgbGluZWFyUHJvZ3Jlc3MgPSBjbGFtcCgwLCB0aGlzLmN1cnJlbnRUaW1lIC8gdGhpcy5kdXJhdGlvbiwgMSk7XG4gICAgICBjb21wbGV0ZWQgPSBsaW5lYXJQcm9ncmVzcyA+PSAxO1xuICAgICAgY29uc3QgZWFzZWRQcm9ncmVzcyA9IGNvbXBsZXRlZCA/IDEgOiB0aGlzLmVhc2luZyhsaW5lYXJQcm9ncmVzcyk7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5mcm9tICsgKHRoaXMudG8gLSB0aGlzLmZyb20pICogZWFzZWRQcm9ncmVzcztcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVycCkge1xuICAgICAgdGhpcy52YWx1ZSA9IGRhbXAodGhpcy52YWx1ZSwgdGhpcy50bywgdGhpcy5sZXJwICogNjAsIGRlbHRhVGltZSk7XG4gICAgICBpZiAoTWF0aC5yb3VuZCh0aGlzLnZhbHVlKSA9PT0gdGhpcy50bykge1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy50bztcbiAgICAgICAgY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudG87XG4gICAgICBjb21wbGV0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29tcGxldGVkKSB7XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICB9XG4gICAgdGhpcy5vblVwZGF0ZT8uKHRoaXMudmFsdWUsIGNvbXBsZXRlZCk7XG4gIH1cbiAgLyoqIFN0b3AgdGhlIGFuaW1hdGlvbiAqL1xuICBzdG9wKCkge1xuICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB1cCB0aGUgYW5pbWF0aW9uIGZyb20gYSBzdGFydGluZyB2YWx1ZSB0byBhbiBlbmRpbmcgdmFsdWVcbiAgICogd2l0aCBvcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBsZXJwaW5nLCBkdXJhdGlvbiwgZWFzaW5nLCBhbmQgb25VcGRhdGUgY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGZyb20gLSBUaGUgc3RhcnRpbmcgdmFsdWVcbiAgICogQHBhcmFtIHRvIC0gVGhlIGVuZGluZyB2YWx1ZVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBhbmltYXRpb25cbiAgICovXG4gIGZyb21Ubyhmcm9tLCB0bywgeyBsZXJwOiBsZXJwMiwgZHVyYXRpb24sIGVhc2luZywgb25TdGFydCwgb25VcGRhdGUgfSkge1xuICAgIHRoaXMuZnJvbSA9IHRoaXMudmFsdWUgPSBmcm9tO1xuICAgIHRoaXMudG8gPSB0bztcbiAgICB0aGlzLmxlcnAgPSBsZXJwMjtcbiAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgdGhpcy5lYXNpbmcgPSBlYXNpbmc7XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IDA7XG4gICAgdGhpcy5pc1J1bm5pbmcgPSB0cnVlO1xuICAgIG9uU3RhcnQ/LigpO1xuICAgIHRoaXMub25VcGRhdGUgPSBvblVwZGF0ZTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvY29yZS9zcmMvZGVib3VuY2UudHNcbmZ1bmN0aW9uIGRlYm91bmNlKGNhbGxiYWNrLCBkZWxheSkge1xuICBsZXQgdGltZXI7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgbGV0IGNvbnRleHQgPSB0aGlzO1xuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRpbWVyID0gdm9pZCAwO1xuICAgICAgY2FsbGJhY2suYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfSwgZGVsYXkpO1xuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9jb3JlL3NyYy9kaW1lbnNpb25zLnRzXG52YXIgRGltZW5zaW9ucyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iod3JhcHBlciwgY29udGVudCwgeyBhdXRvUmVzaXplID0gdHJ1ZSwgZGVib3VuY2U6IGRlYm91bmNlVmFsdWUgPSAyNTAgfSA9IHt9KSB7XG4gICAgdGhpcy53cmFwcGVyID0gd3JhcHBlcjtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIGlmIChhdXRvUmVzaXplKSB7XG4gICAgICB0aGlzLmRlYm91bmNlZFJlc2l6ZSA9IGRlYm91bmNlKHRoaXMucmVzaXplLCBkZWJvdW5jZVZhbHVlKTtcbiAgICAgIGlmICh0aGlzLndyYXBwZXIgaW5zdGFuY2VvZiBXaW5kb3cpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5kZWJvdW5jZWRSZXNpemUsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud3JhcHBlclJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKHRoaXMuZGVib3VuY2VkUmVzaXplKTtcbiAgICAgICAgdGhpcy53cmFwcGVyUmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLndyYXBwZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5jb250ZW50UmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIodGhpcy5kZWJvdW5jZWRSZXNpemUpO1xuICAgICAgdGhpcy5jb250ZW50UmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmNvbnRlbnQpO1xuICAgIH1cbiAgICB0aGlzLnJlc2l6ZSgpO1xuICB9XG4gIHdpZHRoID0gMDtcbiAgaGVpZ2h0ID0gMDtcbiAgc2Nyb2xsSGVpZ2h0ID0gMDtcbiAgc2Nyb2xsV2lkdGggPSAwO1xuICAvLyBUaGVzZSBhcmUgaW5zdGFuY2lhdGVkIGluIHRoZSBjb25zdHJ1Y3RvciBhcyB0aGV5IG5lZWQgaW5mb3JtYXRpb24gZnJvbSB0aGUgb3B0aW9uc1xuICBkZWJvdW5jZWRSZXNpemU7XG4gIHdyYXBwZXJSZXNpemVPYnNlcnZlcjtcbiAgY29udGVudFJlc2l6ZU9ic2VydmVyO1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMud3JhcHBlclJlc2l6ZU9ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5jb250ZW50UmVzaXplT2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICBpZiAodGhpcy53cmFwcGVyID09PSB3aW5kb3cgJiYgdGhpcy5kZWJvdW5jZWRSZXNpemUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuZGVib3VuY2VkUmVzaXplLCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJlc2l6ZSA9ICgpID0+IHtcbiAgICB0aGlzLm9uV3JhcHBlclJlc2l6ZSgpO1xuICAgIHRoaXMub25Db250ZW50UmVzaXplKCk7XG4gIH07XG4gIG9uV3JhcHBlclJlc2l6ZSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy53cmFwcGVyIGluc3RhbmNlb2YgV2luZG93KSB7XG4gICAgICB0aGlzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMud3JhcHBlci5jbGllbnRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy53cmFwcGVyLmNsaWVudEhlaWdodDtcbiAgICB9XG4gIH07XG4gIG9uQ29udGVudFJlc2l6ZSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy53cmFwcGVyIGluc3RhbmNlb2YgV2luZG93KSB7XG4gICAgICB0aGlzLnNjcm9sbEhlaWdodCA9IHRoaXMuY29udGVudC5zY3JvbGxIZWlnaHQ7XG4gICAgICB0aGlzLnNjcm9sbFdpZHRoID0gdGhpcy5jb250ZW50LnNjcm9sbFdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNjcm9sbEhlaWdodCA9IHRoaXMud3JhcHBlci5zY3JvbGxIZWlnaHQ7XG4gICAgICB0aGlzLnNjcm9sbFdpZHRoID0gdGhpcy53cmFwcGVyLnNjcm9sbFdpZHRoO1xuICAgIH1cbiAgfTtcbiAgZ2V0IGxpbWl0KCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB0aGlzLnNjcm9sbFdpZHRoIC0gdGhpcy53aWR0aCxcbiAgICAgIHk6IHRoaXMuc2Nyb2xsSGVpZ2h0IC0gdGhpcy5oZWlnaHRcbiAgICB9O1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9jb3JlL3NyYy9lbWl0dGVyLnRzXG52YXIgRW1pdHRlciA9IGNsYXNzIHtcbiAgZXZlbnRzID0ge307XG4gIC8qKlxuICAgKiBFbWl0IGFuIGV2ZW50IHdpdGggdGhlIGdpdmVuIGRhdGFcbiAgICogQHBhcmFtIGV2ZW50IEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIGFyZ3MgRGF0YSB0byBwYXNzIHRvIHRoZSBldmVudCBoYW5kbGVyc1xuICAgKi9cbiAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgIGxldCBjYWxsYmFja3MgPSB0aGlzLmV2ZW50c1tldmVudF0gfHwgW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY2FsbGJhY2tzW2ldPy4oLi4uYXJncyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBjYWxsYmFjayB0byB0aGUgZXZlbnRcbiAgICogQHBhcmFtIGV2ZW50IEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIGNiIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIFVuc3Vic2NyaWJlIGZ1bmN0aW9uXG4gICAqL1xuICBvbihldmVudCwgY2IpIHtcbiAgICB0aGlzLmV2ZW50c1tldmVudF0/LnB1c2goY2IpIHx8ICh0aGlzLmV2ZW50c1tldmVudF0gPSBbY2JdKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpcy5ldmVudHNbZXZlbnRdID0gdGhpcy5ldmVudHNbZXZlbnRdPy5maWx0ZXIoKGkpID0+IGNiICE9PSBpKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBldmVudFxuICAgKiBAcGFyYW0gZXZlbnQgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICovXG4gIG9mZihldmVudCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmV2ZW50c1tldmVudF0gPSB0aGlzLmV2ZW50c1tldmVudF0/LmZpbHRlcigoaSkgPT4gY2FsbGJhY2sgIT09IGkpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGV2ZW50IGxpc3RlbmVycyBhbmQgY2xlYW4gdXBcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvY29yZS9zcmMvdmlydHVhbC1zY3JvbGwudHNcbnZhciBMSU5FX0hFSUdIVCA9IDEwMCAvIDY7XG52YXIgbGlzdGVuZXJPcHRpb25zID0geyBwYXNzaXZlOiBmYWxzZSB9O1xudmFyIFZpcnR1YWxTY3JvbGwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMgPSB7IHdoZWVsTXVsdGlwbGllcjogMSwgdG91Y2hNdWx0aXBsaWVyOiAxIH0pIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vbldpbmRvd1Jlc2l6ZSwgZmFsc2UpO1xuICAgIHRoaXMub25XaW5kb3dSZXNpemUoKTtcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMub25XaGVlbCwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwidG91Y2hzdGFydFwiLFxuICAgICAgdGhpcy5vblRvdWNoU3RhcnQsXG4gICAgICBsaXN0ZW5lck9wdGlvbnNcbiAgICApO1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJ0b3VjaG1vdmVcIixcbiAgICAgIHRoaXMub25Ub3VjaE1vdmUsXG4gICAgICBsaXN0ZW5lck9wdGlvbnNcbiAgICApO1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5vblRvdWNoRW5kLCBsaXN0ZW5lck9wdGlvbnMpO1xuICB9XG4gIHRvdWNoU3RhcnQgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG4gIGxhc3REZWx0YSA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbiAgd2luZG93ID0ge1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9O1xuICBlbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgLyoqXG4gICAqIEFkZCBhbiBldmVudCBsaXN0ZW5lciBmb3IgdGhlIGdpdmVuIGV2ZW50IGFuZCBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICovXG4gIG9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmVtaXR0ZXIub24oZXZlbnQsIGNhbGxiYWNrKTtcbiAgfVxuICAvKiogUmVtb3ZlIGFsbCBldmVudCBsaXN0ZW5lcnMgYW5kIGNsZWFuIHVwICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5lbWl0dGVyLmRlc3Ryb3koKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm9uV2luZG93UmVzaXplLCBmYWxzZSk7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCB0aGlzLm9uV2hlZWwsIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBcInRvdWNoc3RhcnRcIixcbiAgICAgIHRoaXMub25Ub3VjaFN0YXJ0LFxuICAgICAgbGlzdGVuZXJPcHRpb25zXG4gICAgKTtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwidG91Y2htb3ZlXCIsXG4gICAgICB0aGlzLm9uVG91Y2hNb3ZlLFxuICAgICAgbGlzdGVuZXJPcHRpb25zXG4gICAgKTtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwidG91Y2hlbmRcIixcbiAgICAgIHRoaXMub25Ub3VjaEVuZCxcbiAgICAgIGxpc3RlbmVyT3B0aW9uc1xuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yICd0b3VjaHN0YXJ0JyBldmVudFxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgVG91Y2ggZXZlbnRcbiAgICovXG4gIG9uVG91Y2hTdGFydCA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gZXZlbnQudGFyZ2V0VG91Y2hlcyA/IGV2ZW50LnRhcmdldFRvdWNoZXNbMF0gOiBldmVudDtcbiAgICB0aGlzLnRvdWNoU3RhcnQueCA9IGNsaWVudFg7XG4gICAgdGhpcy50b3VjaFN0YXJ0LnkgPSBjbGllbnRZO1xuICAgIHRoaXMubGFzdERlbHRhID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICAgIHRoaXMuZW1pdHRlci5lbWl0KFwic2Nyb2xsXCIsIHtcbiAgICAgIGRlbHRhWDogMCxcbiAgICAgIGRlbHRhWTogMCxcbiAgICAgIGV2ZW50XG4gICAgfSk7XG4gIH07XG4gIC8qKiBFdmVudCBoYW5kbGVyIGZvciAndG91Y2htb3ZlJyBldmVudCAqL1xuICBvblRvdWNoTW92ZSA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gZXZlbnQudGFyZ2V0VG91Y2hlcyA/IGV2ZW50LnRhcmdldFRvdWNoZXNbMF0gOiBldmVudDtcbiAgICBjb25zdCBkZWx0YVggPSAtKGNsaWVudFggLSB0aGlzLnRvdWNoU3RhcnQueCkgKiB0aGlzLm9wdGlvbnMudG91Y2hNdWx0aXBsaWVyO1xuICAgIGNvbnN0IGRlbHRhWSA9IC0oY2xpZW50WSAtIHRoaXMudG91Y2hTdGFydC55KSAqIHRoaXMub3B0aW9ucy50b3VjaE11bHRpcGxpZXI7XG4gICAgdGhpcy50b3VjaFN0YXJ0LnggPSBjbGllbnRYO1xuICAgIHRoaXMudG91Y2hTdGFydC55ID0gY2xpZW50WTtcbiAgICB0aGlzLmxhc3REZWx0YSA9IHtcbiAgICAgIHg6IGRlbHRhWCxcbiAgICAgIHk6IGRlbHRhWVxuICAgIH07XG4gICAgdGhpcy5lbWl0dGVyLmVtaXQoXCJzY3JvbGxcIiwge1xuICAgICAgZGVsdGFYLFxuICAgICAgZGVsdGFZLFxuICAgICAgZXZlbnRcbiAgICB9KTtcbiAgfTtcbiAgb25Ub3VjaEVuZCA9IChldmVudCkgPT4ge1xuICAgIHRoaXMuZW1pdHRlci5lbWl0KFwic2Nyb2xsXCIsIHtcbiAgICAgIGRlbHRhWDogdGhpcy5sYXN0RGVsdGEueCxcbiAgICAgIGRlbHRhWTogdGhpcy5sYXN0RGVsdGEueSxcbiAgICAgIGV2ZW50XG4gICAgfSk7XG4gIH07XG4gIC8qKiBFdmVudCBoYW5kbGVyIGZvciAnd2hlZWwnIGV2ZW50ICovXG4gIG9uV2hlZWwgPSAoZXZlbnQpID0+IHtcbiAgICBsZXQgeyBkZWx0YVgsIGRlbHRhWSwgZGVsdGFNb2RlIH0gPSBldmVudDtcbiAgICBjb25zdCBtdWx0aXBsaWVyWCA9IGRlbHRhTW9kZSA9PT0gMSA/IExJTkVfSEVJR0hUIDogZGVsdGFNb2RlID09PSAyID8gdGhpcy53aW5kb3cud2lkdGggOiAxO1xuICAgIGNvbnN0IG11bHRpcGxpZXJZID0gZGVsdGFNb2RlID09PSAxID8gTElORV9IRUlHSFQgOiBkZWx0YU1vZGUgPT09IDIgPyB0aGlzLndpbmRvdy5oZWlnaHQgOiAxO1xuICAgIGRlbHRhWCAqPSBtdWx0aXBsaWVyWDtcbiAgICBkZWx0YVkgKj0gbXVsdGlwbGllclk7XG4gICAgZGVsdGFYICo9IHRoaXMub3B0aW9ucy53aGVlbE11bHRpcGxpZXI7XG4gICAgZGVsdGFZICo9IHRoaXMub3B0aW9ucy53aGVlbE11bHRpcGxpZXI7XG4gICAgdGhpcy5lbWl0dGVyLmVtaXQoXCJzY3JvbGxcIiwgeyBkZWx0YVgsIGRlbHRhWSwgZXZlbnQgfSk7XG4gIH07XG4gIG9uV2luZG93UmVzaXplID0gKCkgPT4ge1xuICAgIHRoaXMud2luZG93ID0ge1xuICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICB9O1xuICB9O1xufTtcblxuLy8gcGFja2FnZXMvY29yZS9zcmMvbGVuaXMudHNcbnZhciBkZWZhdWx0RWFzaW5nID0gKHQpID0+IE1hdGgubWluKDEsIDEuMDAxIC0gTWF0aC5wb3coMiwgLTEwICogdCkpO1xudmFyIExlbmlzID0gY2xhc3Mge1xuICBfaXNTY3JvbGxpbmcgPSBmYWxzZTtcbiAgLy8gdHJ1ZSB3aGVuIHNjcm9sbCBpcyBhbmltYXRpbmdcbiAgX2lzU3RvcHBlZCA9IGZhbHNlO1xuICAvLyB0cnVlIGlmIHVzZXIgc2hvdWxkIG5vdCBiZSBhYmxlIHRvIHNjcm9sbCAtIGVuYWJsZS9kaXNhYmxlIHByb2dyYW1tYXRpY2FsbHlcbiAgX2lzTG9ja2VkID0gZmFsc2U7XG4gIC8vIHNhbWUgYXMgaXNTdG9wcGVkIGJ1dCBlbmFibGVkL2Rpc2FibGVkIHdoZW4gc2Nyb2xsIHJlYWNoZXMgdGFyZ2V0XG4gIF9wcmV2ZW50TmV4dE5hdGl2ZVNjcm9sbEV2ZW50ID0gZmFsc2U7XG4gIF9yZXNldFZlbG9jaXR5VGltZW91dCA9IG51bGw7XG4gIF9fcmFmSUQgPSBudWxsO1xuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdGhlIHVzZXIgaXMgdG91Y2hpbmcgdGhlIHNjcmVlblxuICAgKi9cbiAgaXNUb3VjaGluZztcbiAgLyoqXG4gICAqIFRoZSB0aW1lIGluIG1zIHNpbmNlIHRoZSBsZW5pcyBpbnN0YW5jZSB3YXMgY3JlYXRlZFxuICAgKi9cbiAgdGltZSA9IDA7XG4gIC8qKlxuICAgKiBVc2VyIGRhdGEgdGhhdCB3aWxsIGJlIGZvcndhcmRlZCB0aHJvdWdoIHRoZSBzY3JvbGwgZXZlbnRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbGVuaXMuc2Nyb2xsVG8oMTAwLCB7XG4gICAqICAgdXNlckRhdGE6IHtcbiAgICogICAgIGZvbzogJ2JhcidcbiAgICogICB9XG4gICAqIH0pXG4gICAqL1xuICB1c2VyRGF0YSA9IHt9O1xuICAvKipcbiAgICogVGhlIGxhc3QgdmVsb2NpdHkgb2YgdGhlIHNjcm9sbFxuICAgKi9cbiAgbGFzdFZlbG9jaXR5ID0gMDtcbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHZlbG9jaXR5IG9mIHRoZSBzY3JvbGxcbiAgICovXG4gIHZlbG9jaXR5ID0gMDtcbiAgLyoqXG4gICAqIFRoZSBkaXJlY3Rpb24gb2YgdGhlIHNjcm9sbFxuICAgKi9cbiAgZGlyZWN0aW9uID0gMDtcbiAgLyoqXG4gICAqIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgbGVuaXMgaW5zdGFuY2VcbiAgICovXG4gIG9wdGlvbnM7XG4gIC8qKlxuICAgKiBUaGUgdGFyZ2V0IHNjcm9sbCB2YWx1ZVxuICAgKi9cbiAgdGFyZ2V0U2Nyb2xsO1xuICAvKipcbiAgICogVGhlIGFuaW1hdGVkIHNjcm9sbCB2YWx1ZVxuICAgKi9cbiAgYW5pbWF0ZWRTY3JvbGw7XG4gIC8vIFRoZXNlIGFyZSBpbnN0YW5jaWF0ZWQgaGVyZSBhcyB0aGV5IGRvbid0IG5lZWQgaW5mb3JtYXRpb24gZnJvbSB0aGUgb3B0aW9uc1xuICBhbmltYXRlID0gbmV3IEFuaW1hdGUoKTtcbiAgZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gIC8vIFRoZXNlIGFyZSBpbnN0YW5jaWF0ZWQgaW4gdGhlIGNvbnN0cnVjdG9yIGFzIHRoZXkgbmVlZCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBvcHRpb25zXG4gIGRpbWVuc2lvbnM7XG4gIC8vIFRoaXMgaXMgbm90IHByaXZhdGUgYmVjYXVzZSBpdCdzIHVzZWQgaW4gdGhlIFNuYXAgY2xhc3NcbiAgdmlydHVhbFNjcm9sbDtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHdyYXBwZXIgPSB3aW5kb3csXG4gICAgY29udGVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICBldmVudHNUYXJnZXQgPSB3cmFwcGVyLFxuICAgIHNtb290aFdoZWVsID0gdHJ1ZSxcbiAgICBzeW5jVG91Y2ggPSBmYWxzZSxcbiAgICBzeW5jVG91Y2hMZXJwID0gMC4wNzUsXG4gICAgdG91Y2hJbmVydGlhRXhwb25lbnQgPSAxLjcsXG4gICAgZHVyYXRpb24sXG4gICAgLy8gaW4gc2Vjb25kc1xuICAgIGVhc2luZyxcbiAgICBsZXJwOiBsZXJwMiA9IDAuMSxcbiAgICBpbmZpbml0ZSA9IGZhbHNlLFxuICAgIG9yaWVudGF0aW9uID0gXCJ2ZXJ0aWNhbFwiLFxuICAgIC8vIHZlcnRpY2FsLCBob3Jpem9udGFsXG4gICAgZ2VzdHVyZU9yaWVudGF0aW9uID0gb3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gXCJib3RoXCIgOiBcInZlcnRpY2FsXCIsXG4gICAgLy8gdmVydGljYWwsIGhvcml6b250YWwsIGJvdGhcbiAgICB0b3VjaE11bHRpcGxpZXIgPSAxLFxuICAgIHdoZWVsTXVsdGlwbGllciA9IDEsXG4gICAgYXV0b1Jlc2l6ZSA9IHRydWUsXG4gICAgcHJldmVudCxcbiAgICB2aXJ0dWFsU2Nyb2xsLFxuICAgIG92ZXJzY3JvbGwgPSB0cnVlLFxuICAgIGF1dG9SYWYgPSBmYWxzZSxcbiAgICBhbmNob3JzID0gZmFsc2UsXG4gICAgYXV0b1RvZ2dsZSA9IGZhbHNlLFxuICAgIC8vIGh0dHBzOi8vY2FuaXVzZS5jb20vP3NlYXJjaD10cmFuc2l0aW9uLWJlaGF2aW9yXG4gICAgYWxsb3dOZXN0ZWRTY3JvbGwgPSBmYWxzZSxcbiAgICBfX2V4cGVyaW1lbnRhbF9fbmFpdmVEaW1lbnNpb25zID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgd2luZG93LmxlbmlzVmVyc2lvbiA9IHZlcnNpb247XG4gICAgaWYgKCF3cmFwcGVyIHx8IHdyYXBwZXIgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgd3JhcHBlciA9IHdpbmRvdztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgZWFzaW5nICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGVhc2luZyA9IGRlZmF1bHRFYXNpbmc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWFzaW5nID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGR1cmF0aW9uICE9PSBcIm51bWJlclwiKSB7XG4gICAgICBkdXJhdGlvbiA9IDE7XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIHdyYXBwZXIsXG4gICAgICBjb250ZW50LFxuICAgICAgZXZlbnRzVGFyZ2V0LFxuICAgICAgc21vb3RoV2hlZWwsXG4gICAgICBzeW5jVG91Y2gsXG4gICAgICBzeW5jVG91Y2hMZXJwLFxuICAgICAgdG91Y2hJbmVydGlhRXhwb25lbnQsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIGVhc2luZyxcbiAgICAgIGxlcnA6IGxlcnAyLFxuICAgICAgaW5maW5pdGUsXG4gICAgICBnZXN0dXJlT3JpZW50YXRpb24sXG4gICAgICBvcmllbnRhdGlvbixcbiAgICAgIHRvdWNoTXVsdGlwbGllcixcbiAgICAgIHdoZWVsTXVsdGlwbGllcixcbiAgICAgIGF1dG9SZXNpemUsXG4gICAgICBwcmV2ZW50LFxuICAgICAgdmlydHVhbFNjcm9sbCxcbiAgICAgIG92ZXJzY3JvbGwsXG4gICAgICBhdXRvUmFmLFxuICAgICAgYW5jaG9ycyxcbiAgICAgIGF1dG9Ub2dnbGUsXG4gICAgICBhbGxvd05lc3RlZFNjcm9sbCxcbiAgICAgIF9fZXhwZXJpbWVudGFsX19uYWl2ZURpbWVuc2lvbnNcbiAgICB9O1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IG5ldyBEaW1lbnNpb25zKHdyYXBwZXIsIGNvbnRlbnQsIHsgYXV0b1Jlc2l6ZSB9KTtcbiAgICB0aGlzLnVwZGF0ZUNsYXNzTmFtZSgpO1xuICAgIHRoaXMudGFyZ2V0U2Nyb2xsID0gdGhpcy5hbmltYXRlZFNjcm9sbCA9IHRoaXMuYWN0dWFsU2Nyb2xsO1xuICAgIHRoaXMub3B0aW9ucy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vbk5hdGl2ZVNjcm9sbCwgZmFsc2UpO1xuICAgIHRoaXMub3B0aW9ucy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxlbmRcIiwgdGhpcy5vblNjcm9sbEVuZCwge1xuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYW5jaG9ycyAmJiB0aGlzLm9wdGlvbnMud3JhcHBlciA9PT0gd2luZG93KSB7XG4gICAgICB0aGlzLm9wdGlvbnMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImNsaWNrXCIsXG4gICAgICAgIHRoaXMub25DbGljayxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcInBvaW50ZXJkb3duXCIsXG4gICAgICB0aGlzLm9uUG9pbnRlckRvd24sXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgdGhpcy52aXJ0dWFsU2Nyb2xsID0gbmV3IFZpcnR1YWxTY3JvbGwoZXZlbnRzVGFyZ2V0LCB7XG4gICAgICB0b3VjaE11bHRpcGxpZXIsXG4gICAgICB3aGVlbE11bHRpcGxpZXJcbiAgICB9KTtcbiAgICB0aGlzLnZpcnR1YWxTY3JvbGwub24oXCJzY3JvbGxcIiwgdGhpcy5vblZpcnR1YWxTY3JvbGwpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1RvZ2dsZSkge1xuICAgICAgdGhpcy5jaGVja092ZXJmbG93KCk7XG4gICAgICB0aGlzLnJvb3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIHRoaXMub25UcmFuc2l0aW9uRW5kLCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9SYWYpIHtcbiAgICAgIHRoaXMuX19yYWZJRCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJhZik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBsZW5pcyBpbnN0YW5jZSwgcmVtb3ZlIGFsbCBldmVudCBsaXN0ZW5lcnMgYW5kIGNsZWFuIHVwIHRoZSBjbGFzcyBuYW1lXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZW1pdHRlci5kZXN0cm95KCk7XG4gICAgdGhpcy5vcHRpb25zLndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwic2Nyb2xsXCIsXG4gICAgICB0aGlzLm9uTmF0aXZlU2Nyb2xsLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHRoaXMub3B0aW9ucy53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxlbmRcIiwgdGhpcy5vblNjcm9sbEVuZCwge1xuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMub3B0aW9ucy53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBcInBvaW50ZXJkb3duXCIsXG4gICAgICB0aGlzLm9uUG9pbnRlckRvd24sXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hbmNob3JzICYmIHRoaXMub3B0aW9ucy53cmFwcGVyID09PSB3aW5kb3cpIHtcbiAgICAgIHRoaXMub3B0aW9ucy53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiY2xpY2tcIixcbiAgICAgICAgdGhpcy5vbkNsaWNrLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy52aXJ0dWFsU2Nyb2xsLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRpbWVuc2lvbnMuZGVzdHJveSgpO1xuICAgIHRoaXMuY2xlYW5VcENsYXNzTmFtZSgpO1xuICAgIGlmICh0aGlzLl9fcmFmSUQpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX19yYWZJRCk7XG4gICAgfVxuICB9XG4gIG9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmVtaXR0ZXIub24oZXZlbnQsIGNhbGxiYWNrKTtcbiAgfVxuICBvZmYoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdHRlci5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgfVxuICBvblNjcm9sbEVuZCA9IChlKSA9PiB7XG4gICAgaWYgKCEoZSBpbnN0YW5jZW9mIEN1c3RvbUV2ZW50KSkge1xuICAgICAgaWYgKHRoaXMuaXNTY3JvbGxpbmcgPT09IFwic21vb3RoXCIgfHwgdGhpcy5pc1Njcm9sbGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGRpc3BhdGNoU2Nyb2xsZW5kRXZlbnQgPSAoKSA9PiB7XG4gICAgdGhpcy5vcHRpb25zLndyYXBwZXIuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBDdXN0b21FdmVudChcInNjcm9sbGVuZFwiLCB7XG4gICAgICAgIGJ1YmJsZXM6IHRoaXMub3B0aW9ucy53cmFwcGVyID09PSB3aW5kb3csXG4gICAgICAgIC8vIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICBsZW5pc1Njcm9sbEVuZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH07XG4gIGdldCBvdmVyZmxvdygpIHtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IHRoaXMuaXNIb3Jpem9udGFsID8gXCJvdmVyZmxvdy14XCIgOiBcIm92ZXJmbG93LXlcIjtcbiAgICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLnJvb3RFbGVtZW50KVtwcm9wZXJ0eV07XG4gIH1cbiAgY2hlY2tPdmVyZmxvdygpIHtcbiAgICBpZiAoW1wiaGlkZGVuXCIsIFwiY2xpcFwiXS5pbmNsdWRlcyh0aGlzLm92ZXJmbG93KSkge1xuICAgICAgdGhpcy5pbnRlcm5hbFN0b3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnRlcm5hbFN0YXJ0KCk7XG4gICAgfVxuICB9XG4gIG9uVHJhbnNpdGlvbkVuZCA9IChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5wcm9wZXJ0eU5hbWUuaW5jbHVkZXMoXCJvdmVyZmxvd1wiKSkge1xuICAgICAgdGhpcy5jaGVja092ZXJmbG93KCk7XG4gICAgfVxuICB9O1xuICBzZXRTY3JvbGwoc2Nyb2xsKSB7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKSB7XG4gICAgICB0aGlzLm9wdGlvbnMud3JhcHBlci5zY3JvbGxUbyh7IGxlZnQ6IHNjcm9sbCwgYmVoYXZpb3I6IFwiaW5zdGFudFwiIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wdGlvbnMud3JhcHBlci5zY3JvbGxUbyh7IHRvcDogc2Nyb2xsLCBiZWhhdmlvcjogXCJpbnN0YW50XCIgfSk7XG4gICAgfVxuICB9XG4gIG9uQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBwYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgY29uc3QgYW5jaG9yID0gcGF0aC5maW5kKFxuICAgICAgKG5vZGUpID0+IG5vZGUgaW5zdGFuY2VvZiBIVE1MQW5jaG9yRWxlbWVudCAmJiBub2RlLmdldEF0dHJpYnV0ZShcImhyZWZcIik/LmluY2x1ZGVzKFwiI1wiKVxuICAgICk7XG4gICAgaWYgKGFuY2hvcikge1xuICAgICAgY29uc3QgaHJlZiA9IGFuY2hvci5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xuICAgICAgaWYgKGhyZWYpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuYW5jaG9ycyA9PT0gXCJvYmplY3RcIiAmJiB0aGlzLm9wdGlvbnMuYW5jaG9ycyA/IHRoaXMub3B0aW9ucy5hbmNob3JzIDogdm9pZCAwO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBgIyR7aHJlZi5zcGxpdChcIiNcIilbMV19YDtcbiAgICAgICAgdGhpcy5zY3JvbGxUbyh0YXJnZXQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgb25Qb2ludGVyRG93biA9IChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5idXR0b24gPT09IDEpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gIH07XG4gIG9uVmlydHVhbFNjcm9sbCA9IChkYXRhKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMudmlydHVhbFNjcm9sbCA9PT0gXCJmdW5jdGlvblwiICYmIHRoaXMub3B0aW9ucy52aXJ0dWFsU2Nyb2xsKGRhdGEpID09PSBmYWxzZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGRlbHRhWCwgZGVsdGFZLCBldmVudCB9ID0gZGF0YTtcbiAgICB0aGlzLmVtaXR0ZXIuZW1pdChcInZpcnR1YWwtc2Nyb2xsXCIsIHsgZGVsdGFYLCBkZWx0YVksIGV2ZW50IH0pO1xuICAgIGlmIChldmVudC5jdHJsS2V5KSByZXR1cm47XG4gICAgaWYgKGV2ZW50LmxlbmlzU3RvcFByb3BhZ2F0aW9uKSByZXR1cm47XG4gICAgY29uc3QgaXNUb3VjaCA9IGV2ZW50LnR5cGUuaW5jbHVkZXMoXCJ0b3VjaFwiKTtcbiAgICBjb25zdCBpc1doZWVsID0gZXZlbnQudHlwZS5pbmNsdWRlcyhcIndoZWVsXCIpO1xuICAgIHRoaXMuaXNUb3VjaGluZyA9IGV2ZW50LnR5cGUgPT09IFwidG91Y2hzdGFydFwiIHx8IGV2ZW50LnR5cGUgPT09IFwidG91Y2htb3ZlXCI7XG4gICAgY29uc3QgaXNDbGlja09yVGFwID0gZGVsdGFYID09PSAwICYmIGRlbHRhWSA9PT0gMDtcbiAgICBjb25zdCBpc1RhcFRvU3RvcCA9IHRoaXMub3B0aW9ucy5zeW5jVG91Y2ggJiYgaXNUb3VjaCAmJiBldmVudC50eXBlID09PSBcInRvdWNoc3RhcnRcIiAmJiBpc0NsaWNrT3JUYXAgJiYgIXRoaXMuaXNTdG9wcGVkICYmICF0aGlzLmlzTG9ja2VkO1xuICAgIGlmIChpc1RhcFRvU3RvcCkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc1Vua25vd25HZXN0dXJlID0gdGhpcy5vcHRpb25zLmdlc3R1cmVPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiICYmIGRlbHRhWSA9PT0gMCB8fCB0aGlzLm9wdGlvbnMuZ2VzdHVyZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiAmJiBkZWx0YVggPT09IDA7XG4gICAgaWYgKGlzQ2xpY2tPclRhcCB8fCBpc1Vua25vd25HZXN0dXJlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjb21wb3NlZFBhdGggPSBldmVudC5jb21wb3NlZFBhdGgoKTtcbiAgICBjb21wb3NlZFBhdGggPSBjb21wb3NlZFBhdGguc2xpY2UoMCwgY29tcG9zZWRQYXRoLmluZGV4T2YodGhpcy5yb290RWxlbWVudCkpO1xuICAgIGNvbnN0IHByZXZlbnQgPSB0aGlzLm9wdGlvbnMucHJldmVudDtcbiAgICBpZiAoISFjb21wb3NlZFBhdGguZmluZChcbiAgICAgIChub2RlKSA9PiBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgKHR5cGVvZiBwcmV2ZW50ID09PSBcImZ1bmN0aW9uXCIgJiYgcHJldmVudD8uKG5vZGUpIHx8IG5vZGUuaGFzQXR0cmlidXRlPy4oXCJkYXRhLWxlbmlzLXByZXZlbnRcIikgfHwgaXNUb3VjaCAmJiBub2RlLmhhc0F0dHJpYnV0ZT8uKFwiZGF0YS1sZW5pcy1wcmV2ZW50LXRvdWNoXCIpIHx8IGlzV2hlZWwgJiYgbm9kZS5oYXNBdHRyaWJ1dGU/LihcImRhdGEtbGVuaXMtcHJldmVudC13aGVlbFwiKSB8fCB0aGlzLm9wdGlvbnMuYWxsb3dOZXN0ZWRTY3JvbGwgJiYgdGhpcy5jaGVja05lc3RlZFNjcm9sbChub2RlLCB7IGRlbHRhWCwgZGVsdGFZIH0pKVxuICAgICkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMuaXNTdG9wcGVkIHx8IHRoaXMuaXNMb2NrZWQpIHtcbiAgICAgIGlmIChldmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzU21vb3RoID0gdGhpcy5vcHRpb25zLnN5bmNUb3VjaCAmJiBpc1RvdWNoIHx8IHRoaXMub3B0aW9ucy5zbW9vdGhXaGVlbCAmJiBpc1doZWVsO1xuICAgIGlmICghaXNTbW9vdGgpIHtcbiAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSBcIm5hdGl2ZVwiO1xuICAgICAgdGhpcy5hbmltYXRlLnN0b3AoKTtcbiAgICAgIGV2ZW50LmxlbmlzU3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGRlbHRhID0gZGVsdGFZO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZ2VzdHVyZU9yaWVudGF0aW9uID09PSBcImJvdGhcIikge1xuICAgICAgZGVsdGEgPSBNYXRoLmFicyhkZWx0YVkpID4gTWF0aC5hYnMoZGVsdGFYKSA/IGRlbHRhWSA6IGRlbHRhWDtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5nZXN0dXJlT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICBkZWx0YSA9IGRlbHRhWDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMub3ZlcnNjcm9sbCB8fCB0aGlzLm9wdGlvbnMuaW5maW5pdGUgfHwgdGhpcy5vcHRpb25zLndyYXBwZXIgIT09IHdpbmRvdyAmJiB0aGlzLmxpbWl0ID4gMCAmJiAodGhpcy5hbmltYXRlZFNjcm9sbCA+IDAgJiYgdGhpcy5hbmltYXRlZFNjcm9sbCA8IHRoaXMubGltaXQgfHwgdGhpcy5hbmltYXRlZFNjcm9sbCA9PT0gMCAmJiBkZWx0YVkgPiAwIHx8IHRoaXMuYW5pbWF0ZWRTY3JvbGwgPT09IHRoaXMubGltaXQgJiYgZGVsdGFZIDwgMCkpIHtcbiAgICAgIGV2ZW50LmxlbmlzU3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGNvbnN0IGlzU3luY1RvdWNoID0gaXNUb3VjaCAmJiB0aGlzLm9wdGlvbnMuc3luY1RvdWNoO1xuICAgIGNvbnN0IGlzVG91Y2hFbmQgPSBpc1RvdWNoICYmIGV2ZW50LnR5cGUgPT09IFwidG91Y2hlbmRcIjtcbiAgICBjb25zdCBoYXNUb3VjaEluZXJ0aWEgPSBpc1RvdWNoRW5kO1xuICAgIGlmIChoYXNUb3VjaEluZXJ0aWEpIHtcbiAgICAgIGRlbHRhID0gTWF0aC5zaWduKHRoaXMudmVsb2NpdHkpICogTWF0aC5wb3coTWF0aC5hYnModGhpcy52ZWxvY2l0eSksIHRoaXMub3B0aW9ucy50b3VjaEluZXJ0aWFFeHBvbmVudCk7XG4gICAgfVxuICAgIHRoaXMuc2Nyb2xsVG8odGhpcy50YXJnZXRTY3JvbGwgKyBkZWx0YSwge1xuICAgICAgcHJvZ3JhbW1hdGljOiBmYWxzZSxcbiAgICAgIC4uLmlzU3luY1RvdWNoID8ge1xuICAgICAgICBsZXJwOiBoYXNUb3VjaEluZXJ0aWEgPyB0aGlzLm9wdGlvbnMuc3luY1RvdWNoTGVycCA6IDFcbiAgICAgICAgLy8gaW1tZWRpYXRlOiAhaGFzVG91Y2hJbmVydGlhLFxuICAgICAgfSA6IHtcbiAgICAgICAgbGVycDogdGhpcy5vcHRpb25zLmxlcnAsXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLm9wdGlvbnMuZHVyYXRpb24sXG4gICAgICAgIGVhc2luZzogdGhpcy5vcHRpb25zLmVhc2luZ1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogRm9yY2UgbGVuaXMgdG8gcmVjYWxjdWxhdGUgdGhlIGRpbWVuc2lvbnNcbiAgICovXG4gIHJlc2l6ZSgpIHtcbiAgICB0aGlzLmRpbWVuc2lvbnMucmVzaXplKCk7XG4gICAgdGhpcy5hbmltYXRlZFNjcm9sbCA9IHRoaXMudGFyZ2V0U2Nyb2xsID0gdGhpcy5hY3R1YWxTY3JvbGw7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgZW1pdCgpIHtcbiAgICB0aGlzLmVtaXR0ZXIuZW1pdChcInNjcm9sbFwiLCB0aGlzKTtcbiAgfVxuICBvbk5hdGl2ZVNjcm9sbCA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5fcmVzZXRWZWxvY2l0eVRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZXNldFZlbG9jaXR5VGltZW91dCk7XG4gICAgICB0aGlzLl9yZXNldFZlbG9jaXR5VGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLl9wcmV2ZW50TmV4dE5hdGl2ZVNjcm9sbEV2ZW50KSB7XG4gICAgICB0aGlzLl9wcmV2ZW50TmV4dE5hdGl2ZVNjcm9sbEV2ZW50ID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2Nyb2xsaW5nID09PSBmYWxzZSB8fCB0aGlzLmlzU2Nyb2xsaW5nID09PSBcIm5hdGl2ZVwiKSB7XG4gICAgICBjb25zdCBsYXN0U2Nyb2xsID0gdGhpcy5hbmltYXRlZFNjcm9sbDtcbiAgICAgIHRoaXMuYW5pbWF0ZWRTY3JvbGwgPSB0aGlzLnRhcmdldFNjcm9sbCA9IHRoaXMuYWN0dWFsU2Nyb2xsO1xuICAgICAgdGhpcy5sYXN0VmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5O1xuICAgICAgdGhpcy52ZWxvY2l0eSA9IHRoaXMuYW5pbWF0ZWRTY3JvbGwgLSBsYXN0U2Nyb2xsO1xuICAgICAgdGhpcy5kaXJlY3Rpb24gPSBNYXRoLnNpZ24oXG4gICAgICAgIHRoaXMuYW5pbWF0ZWRTY3JvbGwgLSBsYXN0U2Nyb2xsXG4gICAgICApO1xuICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gXCJuYXRpdmVcIjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdCgpO1xuICAgICAgaWYgKHRoaXMudmVsb2NpdHkgIT09IDApIHtcbiAgICAgICAgdGhpcy5fcmVzZXRWZWxvY2l0eVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmxhc3RWZWxvY2l0eSA9IHRoaXMudmVsb2NpdHk7XG4gICAgICAgICAgdGhpcy52ZWxvY2l0eSA9IDA7XG4gICAgICAgICAgdGhpcy5pc1Njcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuZW1pdCgpO1xuICAgICAgICB9LCA0MDApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5pc0xvY2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmFuaW1hdGVkU2Nyb2xsID0gdGhpcy50YXJnZXRTY3JvbGwgPSB0aGlzLmFjdHVhbFNjcm9sbDtcbiAgICB0aGlzLmxhc3RWZWxvY2l0eSA9IHRoaXMudmVsb2NpdHkgPSAwO1xuICAgIHRoaXMuYW5pbWF0ZS5zdG9wKCk7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IGxlbmlzIHNjcm9sbCBhZnRlciBpdCBoYXMgYmVlbiBzdG9wcGVkXG4gICAqL1xuICBzdGFydCgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSByZXR1cm47XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvVG9nZ2xlKSB7XG4gICAgICB0aGlzLnJvb3RFbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwib3ZlcmZsb3dcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaW50ZXJuYWxTdGFydCgpO1xuICB9XG4gIGludGVybmFsU3RhcnQoKSB7XG4gICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkgcmV0dXJuO1xuICAgIHRoaXMucmVzZXQoKTtcbiAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIC8qKlxuICAgKiBTdG9wIGxlbmlzIHNjcm9sbFxuICAgKi9cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHJldHVybjtcbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9Ub2dnbGUpIHtcbiAgICAgIHRoaXMucm9vdEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCJvdmVyZmxvd1wiLCBcImNsaXBcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaW50ZXJuYWxTdG9wKCk7XG4gIH1cbiAgaW50ZXJuYWxTdG9wKCkge1xuICAgIGlmICh0aGlzLmlzU3RvcHBlZCkgcmV0dXJuO1xuICAgIHRoaXMucmVzZXQoKTtcbiAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlcXVlc3RBbmltYXRpb25GcmFtZSBmb3IgbGVuaXNcbiAgICpcbiAgICogQHBhcmFtIHRpbWUgVGhlIHRpbWUgaW4gbXMgZnJvbSBhbiBleHRlcm5hbCBjbG9jayBsaWtlIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIG9yIFRlbXB1c1xuICAgKi9cbiAgcmFmID0gKHRpbWUpID0+IHtcbiAgICBjb25zdCBkZWx0YVRpbWUgPSB0aW1lIC0gKHRoaXMudGltZSB8fCB0aW1lKTtcbiAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgIHRoaXMuYW5pbWF0ZS5hZHZhbmNlKGRlbHRhVGltZSAqIDFlLTMpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1JhZikge1xuICAgICAgdGhpcy5fX3JhZklEID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBTY3JvbGwgdG8gYSB0YXJnZXQgdmFsdWVcbiAgICpcbiAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IHZhbHVlIHRvIHNjcm9sbCB0b1xuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIHNjcm9sbFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBsZW5pcy5zY3JvbGxUbygxMDAsIHtcbiAgICogICBvZmZzZXQ6IDEwMCxcbiAgICogICBkdXJhdGlvbjogMSxcbiAgICogICBlYXNpbmc6ICh0KSA9PiAxIC0gTWF0aC5jb3MoKHQgKiBNYXRoLlBJKSAvIDIpLFxuICAgKiAgIGxlcnA6IDAuMSxcbiAgICogICBvblN0YXJ0OiAoKSA9PiB7XG4gICAqICAgICBjb25zb2xlLmxvZygnb25TdGFydCcpXG4gICAqICAgfSxcbiAgICogICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAqICAgICBjb25zb2xlLmxvZygnb25Db21wbGV0ZScpXG4gICAqICAgfSxcbiAgICogfSlcbiAgICovXG4gIHNjcm9sbFRvKHRhcmdldCwge1xuICAgIG9mZnNldCA9IDAsXG4gICAgaW1tZWRpYXRlID0gZmFsc2UsXG4gICAgbG9jayA9IGZhbHNlLFxuICAgIGR1cmF0aW9uID0gdGhpcy5vcHRpb25zLmR1cmF0aW9uLFxuICAgIGVhc2luZyA9IHRoaXMub3B0aW9ucy5lYXNpbmcsXG4gICAgbGVycDogbGVycDIgPSB0aGlzLm9wdGlvbnMubGVycCxcbiAgICBvblN0YXJ0LFxuICAgIG9uQ29tcGxldGUsXG4gICAgZm9yY2UgPSBmYWxzZSxcbiAgICAvLyBzY3JvbGwgZXZlbiBpZiBzdG9wcGVkXG4gICAgcHJvZ3JhbW1hdGljID0gdHJ1ZSxcbiAgICAvLyBjYWxsZWQgZnJvbSBvdXRzaWRlIG9mIHRoZSBjbGFzc1xuICAgIHVzZXJEYXRhXG4gIH0gPSB7fSkge1xuICAgIGlmICgodGhpcy5pc1N0b3BwZWQgfHwgdGhpcy5pc0xvY2tlZCkgJiYgIWZvcmNlKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwic3RyaW5nXCIgJiYgW1widG9wXCIsIFwibGVmdFwiLCBcInN0YXJ0XCIsIFwiI1wiXS5pbmNsdWRlcyh0YXJnZXQpKSB7XG4gICAgICB0YXJnZXQgPSAwO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIiAmJiBbXCJib3R0b21cIiwgXCJyaWdodFwiLCBcImVuZFwiXS5pbmNsdWRlcyh0YXJnZXQpKSB7XG4gICAgICB0YXJnZXQgPSB0aGlzLmxpbWl0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbm9kZTtcbiAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIGlmICh0YXJnZXQgPT09IFwiI3RvcFwiKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJMZW5pczogVGFyZ2V0IG5vdCBmb3VuZFwiLCB0YXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiB0YXJnZXQ/Lm5vZGVUeXBlKSB7XG4gICAgICAgIG5vZGUgPSB0YXJnZXQ7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLndyYXBwZXIgIT09IHdpbmRvdykge1xuICAgICAgICAgIGNvbnN0IHdyYXBwZXJSZWN0ID0gdGhpcy5yb290RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBvZmZzZXQgLT0gdGhpcy5pc0hvcml6b250YWwgPyB3cmFwcGVyUmVjdC5sZWZ0IDogd3JhcHBlclJlY3QudG9wO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0YXJnZXQgPSAodGhpcy5pc0hvcml6b250YWwgPyByZWN0LmxlZnQgOiByZWN0LnRvcCkgKyB0aGlzLmFuaW1hdGVkU2Nyb2xsO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gXCJudW1iZXJcIikgcmV0dXJuO1xuICAgIHRhcmdldCArPSBvZmZzZXQ7XG4gICAgdGFyZ2V0ID0gTWF0aC5yb3VuZCh0YXJnZXQpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuaW5maW5pdGUpIHtcbiAgICAgIGlmIChwcm9ncmFtbWF0aWMpIHtcbiAgICAgICAgdGhpcy50YXJnZXRTY3JvbGwgPSB0aGlzLmFuaW1hdGVkU2Nyb2xsID0gdGhpcy5zY3JvbGw7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdGFyZ2V0IC0gdGhpcy5hbmltYXRlZFNjcm9sbDtcbiAgICAgICAgaWYgKGRpc3RhbmNlID4gdGhpcy5saW1pdCAvIDIpIHtcbiAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQgLSB0aGlzLmxpbWl0O1xuICAgICAgICB9IGVsc2UgaWYgKGRpc3RhbmNlIDwgLXRoaXMubGltaXQgLyAyKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0ICsgdGhpcy5saW1pdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQgPSBjbGFtcCgwLCB0YXJnZXQsIHRoaXMubGltaXQpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0ID09PSB0aGlzLnRhcmdldFNjcm9sbCkge1xuICAgICAgb25TdGFydD8uKHRoaXMpO1xuICAgICAgb25Db21wbGV0ZT8uKHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVzZXJEYXRhID0gdXNlckRhdGEgPz8ge307XG4gICAgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgdGhpcy5hbmltYXRlZFNjcm9sbCA9IHRoaXMudGFyZ2V0U2Nyb2xsID0gdGFyZ2V0O1xuICAgICAgdGhpcy5zZXRTY3JvbGwodGhpcy5zY3JvbGwpO1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgdGhpcy5wcmV2ZW50TmV4dE5hdGl2ZVNjcm9sbEV2ZW50KCk7XG4gICAgICB0aGlzLmVtaXQoKTtcbiAgICAgIG9uQ29tcGxldGU/Lih0aGlzKTtcbiAgICAgIHRoaXMudXNlckRhdGEgPSB7fTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hTY3JvbGxlbmRFdmVudCgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghcHJvZ3JhbW1hdGljKSB7XG4gICAgICB0aGlzLnRhcmdldFNjcm9sbCA9IHRhcmdldDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgZWFzaW5nICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGVhc2luZyA9IGRlZmF1bHRFYXNpbmc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWFzaW5nID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGR1cmF0aW9uICE9PSBcIm51bWJlclwiKSB7XG4gICAgICBkdXJhdGlvbiA9IDE7XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0ZS5mcm9tVG8odGhpcy5hbmltYXRlZFNjcm9sbCwgdGFyZ2V0LCB7XG4gICAgICBkdXJhdGlvbixcbiAgICAgIGVhc2luZyxcbiAgICAgIGxlcnA6IGxlcnAyLFxuICAgICAgb25TdGFydDogKCkgPT4ge1xuICAgICAgICBpZiAobG9jaykgdGhpcy5pc0xvY2tlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSBcInNtb290aFwiO1xuICAgICAgICBvblN0YXJ0Py4odGhpcyk7XG4gICAgICB9LFxuICAgICAgb25VcGRhdGU6ICh2YWx1ZSwgY29tcGxldGVkKSA9PiB7XG4gICAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSBcInNtb290aFwiO1xuICAgICAgICB0aGlzLmxhc3RWZWxvY2l0eSA9IHRoaXMudmVsb2NpdHk7XG4gICAgICAgIHRoaXMudmVsb2NpdHkgPSB2YWx1ZSAtIHRoaXMuYW5pbWF0ZWRTY3JvbGw7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gTWF0aC5zaWduKHRoaXMudmVsb2NpdHkpO1xuICAgICAgICB0aGlzLmFuaW1hdGVkU2Nyb2xsID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc2V0U2Nyb2xsKHRoaXMuc2Nyb2xsKTtcbiAgICAgICAgaWYgKHByb2dyYW1tYXRpYykge1xuICAgICAgICAgIHRoaXMudGFyZ2V0U2Nyb2xsID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb21wbGV0ZWQpIHRoaXMuZW1pdCgpO1xuICAgICAgICBpZiAoY29tcGxldGVkKSB7XG4gICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgIHRoaXMuZW1pdCgpO1xuICAgICAgICAgIG9uQ29tcGxldGU/Lih0aGlzKTtcbiAgICAgICAgICB0aGlzLnVzZXJEYXRhID0ge307XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hTY3JvbGxlbmRFdmVudCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMucHJldmVudE5leHROYXRpdmVTY3JvbGxFdmVudCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcHJldmVudE5leHROYXRpdmVTY3JvbGxFdmVudCgpIHtcbiAgICB0aGlzLl9wcmV2ZW50TmV4dE5hdGl2ZVNjcm9sbEV2ZW50ID0gdHJ1ZTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5fcHJldmVudE5leHROYXRpdmVTY3JvbGxFdmVudCA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG4gIGNoZWNrTmVzdGVkU2Nyb2xsKG5vZGUsIHsgZGVsdGFYLCBkZWx0YVkgfSkge1xuICAgIGNvbnN0IHRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGNhY2hlID0gbm9kZS5fbGVuaXMgPz89IHt9O1xuICAgIGxldCBoYXNPdmVyZmxvd1gsIGhhc092ZXJmbG93WSwgaXNTY3JvbGxhYmxlWCwgaXNTY3JvbGxhYmxlWSwgc2Nyb2xsV2lkdGgsIHNjcm9sbEhlaWdodCwgY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDtcbiAgICBjb25zdCBnZXN0dXJlT3JpZW50YXRpb24gPSB0aGlzLm9wdGlvbnMuZ2VzdHVyZU9yaWVudGF0aW9uO1xuICAgIGlmICh0aW1lIC0gKGNhY2hlLnRpbWUgPz8gMCkgPiAyZTMpIHtcbiAgICAgIGNhY2hlLnRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgICAgY2FjaGUuY29tcHV0ZWRTdHlsZSA9IGNvbXB1dGVkU3R5bGU7XG4gICAgICBjb25zdCBvdmVyZmxvd1hTdHJpbmcgPSBjb21wdXRlZFN0eWxlLm92ZXJmbG93WDtcbiAgICAgIGNvbnN0IG92ZXJmbG93WVN0cmluZyA9IGNvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuICAgICAgaGFzT3ZlcmZsb3dYID0gW1wiYXV0b1wiLCBcIm92ZXJsYXlcIiwgXCJzY3JvbGxcIl0uaW5jbHVkZXMob3ZlcmZsb3dYU3RyaW5nKTtcbiAgICAgIGhhc092ZXJmbG93WSA9IFtcImF1dG9cIiwgXCJvdmVybGF5XCIsIFwic2Nyb2xsXCJdLmluY2x1ZGVzKG92ZXJmbG93WVN0cmluZyk7XG4gICAgICBjYWNoZS5oYXNPdmVyZmxvd1ggPSBoYXNPdmVyZmxvd1g7XG4gICAgICBjYWNoZS5oYXNPdmVyZmxvd1kgPSBoYXNPdmVyZmxvd1k7XG4gICAgICBpZiAoIWhhc092ZXJmbG93WCAmJiAhaGFzT3ZlcmZsb3dZKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoZ2VzdHVyZU9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgJiYgIWhhc092ZXJmbG93WSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGdlc3R1cmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgJiYgIWhhc092ZXJmbG93WCkgcmV0dXJuIGZhbHNlO1xuICAgICAgc2Nyb2xsV2lkdGggPSBub2RlLnNjcm9sbFdpZHRoO1xuICAgICAgc2Nyb2xsSGVpZ2h0ID0gbm9kZS5zY3JvbGxIZWlnaHQ7XG4gICAgICBjbGllbnRXaWR0aCA9IG5vZGUuY2xpZW50V2lkdGg7XG4gICAgICBjbGllbnRIZWlnaHQgPSBub2RlLmNsaWVudEhlaWdodDtcbiAgICAgIGlzU2Nyb2xsYWJsZVggPSBzY3JvbGxXaWR0aCA+IGNsaWVudFdpZHRoO1xuICAgICAgaXNTY3JvbGxhYmxlWSA9IHNjcm9sbEhlaWdodCA+IGNsaWVudEhlaWdodDtcbiAgICAgIGNhY2hlLmlzU2Nyb2xsYWJsZVggPSBpc1Njcm9sbGFibGVYO1xuICAgICAgY2FjaGUuaXNTY3JvbGxhYmxlWSA9IGlzU2Nyb2xsYWJsZVk7XG4gICAgICBjYWNoZS5zY3JvbGxXaWR0aCA9IHNjcm9sbFdpZHRoO1xuICAgICAgY2FjaGUuc2Nyb2xsSGVpZ2h0ID0gc2Nyb2xsSGVpZ2h0O1xuICAgICAgY2FjaGUuY2xpZW50V2lkdGggPSBjbGllbnRXaWR0aDtcbiAgICAgIGNhY2hlLmNsaWVudEhlaWdodCA9IGNsaWVudEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNTY3JvbGxhYmxlWCA9IGNhY2hlLmlzU2Nyb2xsYWJsZVg7XG4gICAgICBpc1Njcm9sbGFibGVZID0gY2FjaGUuaXNTY3JvbGxhYmxlWTtcbiAgICAgIGhhc092ZXJmbG93WCA9IGNhY2hlLmhhc092ZXJmbG93WDtcbiAgICAgIGhhc092ZXJmbG93WSA9IGNhY2hlLmhhc092ZXJmbG93WTtcbiAgICAgIHNjcm9sbFdpZHRoID0gY2FjaGUuc2Nyb2xsV2lkdGg7XG4gICAgICBzY3JvbGxIZWlnaHQgPSBjYWNoZS5zY3JvbGxIZWlnaHQ7XG4gICAgICBjbGllbnRXaWR0aCA9IGNhY2hlLmNsaWVudFdpZHRoO1xuICAgICAgY2xpZW50SGVpZ2h0ID0gY2FjaGUuY2xpZW50SGVpZ2h0O1xuICAgIH1cbiAgICBpZiAoIWhhc092ZXJmbG93WCAmJiAhaGFzT3ZlcmZsb3dZIHx8ICFpc1Njcm9sbGFibGVYICYmICFpc1Njcm9sbGFibGVZKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChnZXN0dXJlT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiAmJiAoIWhhc092ZXJmbG93WSB8fCAhaXNTY3JvbGxhYmxlWSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGdlc3R1cmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgJiYgKCFoYXNPdmVyZmxvd1ggfHwgIWlzU2Nyb2xsYWJsZVgpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBvcmllbnRhdGlvbjtcbiAgICBpZiAoZ2VzdHVyZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgb3JpZW50YXRpb24gPSBcInhcIjtcbiAgICB9IGVsc2UgaWYgKGdlc3R1cmVPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICBvcmllbnRhdGlvbiA9IFwieVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpc1Njcm9sbGluZ1ggPSBkZWx0YVggIT09IDA7XG4gICAgICBjb25zdCBpc1Njcm9sbGluZ1kgPSBkZWx0YVkgIT09IDA7XG4gICAgICBpZiAoaXNTY3JvbGxpbmdYICYmIGhhc092ZXJmbG93WCAmJiBpc1Njcm9sbGFibGVYKSB7XG4gICAgICAgIG9yaWVudGF0aW9uID0gXCJ4XCI7XG4gICAgICB9XG4gICAgICBpZiAoaXNTY3JvbGxpbmdZICYmIGhhc092ZXJmbG93WSAmJiBpc1Njcm9sbGFibGVZKSB7XG4gICAgICAgIG9yaWVudGF0aW9uID0gXCJ5XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghb3JpZW50YXRpb24pIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2Nyb2xsLCBtYXhTY3JvbGwsIGRlbHRhLCBoYXNPdmVyZmxvdywgaXNTY3JvbGxhYmxlO1xuICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJ4XCIpIHtcbiAgICAgIHNjcm9sbCA9IG5vZGUuc2Nyb2xsTGVmdDtcbiAgICAgIG1heFNjcm9sbCA9IHNjcm9sbFdpZHRoIC0gY2xpZW50V2lkdGg7XG4gICAgICBkZWx0YSA9IGRlbHRhWDtcbiAgICAgIGhhc092ZXJmbG93ID0gaGFzT3ZlcmZsb3dYO1xuICAgICAgaXNTY3JvbGxhYmxlID0gaXNTY3JvbGxhYmxlWDtcbiAgICB9IGVsc2UgaWYgKG9yaWVudGF0aW9uID09PSBcInlcIikge1xuICAgICAgc2Nyb2xsID0gbm9kZS5zY3JvbGxUb3A7XG4gICAgICBtYXhTY3JvbGwgPSBzY3JvbGxIZWlnaHQgLSBjbGllbnRIZWlnaHQ7XG4gICAgICBkZWx0YSA9IGRlbHRhWTtcbiAgICAgIGhhc092ZXJmbG93ID0gaGFzT3ZlcmZsb3dZO1xuICAgICAgaXNTY3JvbGxhYmxlID0gaXNTY3JvbGxhYmxlWTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB3aWxsU2Nyb2xsID0gZGVsdGEgPiAwID8gc2Nyb2xsIDwgbWF4U2Nyb2xsIDogc2Nyb2xsID4gMDtcbiAgICByZXR1cm4gd2lsbFNjcm9sbCAmJiBoYXNPdmVyZmxvdyAmJiBpc1Njcm9sbGFibGU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSByb290IGVsZW1lbnQgb24gd2hpY2ggbGVuaXMgaXMgaW5zdGFuY2VkXG4gICAqL1xuICBnZXQgcm9vdEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy53cmFwcGVyID09PSB3aW5kb3cgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiB0aGlzLm9wdGlvbnMud3JhcHBlcjtcbiAgfVxuICAvKipcbiAgICogVGhlIGxpbWl0IHdoaWNoIGlzIHRoZSBtYXhpbXVtIHNjcm9sbCB2YWx1ZVxuICAgKi9cbiAgZ2V0IGxpbWl0KCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuX19leHBlcmltZW50YWxfX25haXZlRGltZW5zaW9ucykge1xuICAgICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RFbGVtZW50LnNjcm9sbFdpZHRoIC0gdGhpcy5yb290RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RFbGVtZW50LnNjcm9sbEhlaWdodCAtIHRoaXMucm9vdEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5kaW1lbnNpb25zLmxpbWl0W3RoaXMuaXNIb3Jpem9udGFsID8gXCJ4XCIgOiBcInlcIl07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgc2Nyb2xsIGlzIGhvcml6b250YWxcbiAgICovXG4gIGdldCBpc0hvcml6b250YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhY3R1YWwgc2Nyb2xsIHZhbHVlXG4gICAqL1xuICBnZXQgYWN0dWFsU2Nyb2xsKCkge1xuICAgIGNvbnN0IHdyYXBwZXIgPSB0aGlzLm9wdGlvbnMud3JhcHBlcjtcbiAgICByZXR1cm4gdGhpcy5pc0hvcml6b250YWwgPyB3cmFwcGVyLnNjcm9sbFggPz8gd3JhcHBlci5zY3JvbGxMZWZ0IDogd3JhcHBlci5zY3JvbGxZID8/IHdyYXBwZXIuc2Nyb2xsVG9wO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzY3JvbGwgdmFsdWVcbiAgICovXG4gIGdldCBzY3JvbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pbmZpbml0ZSA/IG1vZHVsbyh0aGlzLmFuaW1hdGVkU2Nyb2xsLCB0aGlzLmxpbWl0KSA6IHRoaXMuYW5pbWF0ZWRTY3JvbGw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcm9ncmVzcyBvZiB0aGUgc2Nyb2xsIHJlbGF0aXZlIHRvIHRoZSBsaW1pdFxuICAgKi9cbiAgZ2V0IHByb2dyZXNzKCkge1xuICAgIHJldHVybiB0aGlzLmxpbWl0ID09PSAwID8gMSA6IHRoaXMuc2Nyb2xsIC8gdGhpcy5saW1pdDtcbiAgfVxuICAvKipcbiAgICogQ3VycmVudCBzY3JvbGwgc3RhdGVcbiAgICovXG4gIGdldCBpc1Njcm9sbGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTY3JvbGxpbmc7XG4gIH1cbiAgc2V0IGlzU2Nyb2xsaW5nKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2lzU2Nyb2xsaW5nICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5faXNTY3JvbGxpbmcgPSB2YWx1ZTtcbiAgICAgIHRoaXMudXBkYXRlQ2xhc3NOYW1lKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBsZW5pcyBpcyBzdG9wcGVkXG4gICAqL1xuICBnZXQgaXNTdG9wcGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0b3BwZWQ7XG4gIH1cbiAgc2V0IGlzU3RvcHBlZCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9pc1N0b3BwZWQgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9pc1N0b3BwZWQgPSB2YWx1ZTtcbiAgICAgIHRoaXMudXBkYXRlQ2xhc3NOYW1lKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBsZW5pcyBpcyBsb2NrZWRcbiAgICovXG4gIGdldCBpc0xvY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNMb2NrZWQ7XG4gIH1cbiAgc2V0IGlzTG9ja2VkKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2lzTG9ja2VkICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5faXNMb2NrZWQgPSB2YWx1ZTtcbiAgICAgIHRoaXMudXBkYXRlQ2xhc3NOYW1lKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBsZW5pcyBpcyBzbW9vdGggc2Nyb2xsaW5nXG4gICAqL1xuICBnZXQgaXNTbW9vdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTY3JvbGxpbmcgPT09IFwic21vb3RoXCI7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjbGFzcyBuYW1lIGFwcGxpZWQgdG8gdGhlIHdyYXBwZXIgZWxlbWVudFxuICAgKi9cbiAgZ2V0IGNsYXNzTmFtZSgpIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJsZW5pc1wiO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1RvZ2dsZSkgY2xhc3NOYW1lICs9IFwiIGxlbmlzLWF1dG9Ub2dnbGVcIjtcbiAgICBpZiAodGhpcy5pc1N0b3BwZWQpIGNsYXNzTmFtZSArPSBcIiBsZW5pcy1zdG9wcGVkXCI7XG4gICAgaWYgKHRoaXMuaXNMb2NrZWQpIGNsYXNzTmFtZSArPSBcIiBsZW5pcy1sb2NrZWRcIjtcbiAgICBpZiAodGhpcy5pc1Njcm9sbGluZykgY2xhc3NOYW1lICs9IFwiIGxlbmlzLXNjcm9sbGluZ1wiO1xuICAgIGlmICh0aGlzLmlzU2Nyb2xsaW5nID09PSBcInNtb290aFwiKSBjbGFzc05hbWUgKz0gXCIgbGVuaXMtc21vb3RoXCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxuICB1cGRhdGVDbGFzc05hbWUoKSB7XG4gICAgdGhpcy5jbGVhblVwQ2xhc3NOYW1lKCk7XG4gICAgdGhpcy5yb290RWxlbWVudC5jbGFzc05hbWUgPSBgJHt0aGlzLnJvb3RFbGVtZW50LmNsYXNzTmFtZX0gJHt0aGlzLmNsYXNzTmFtZX1gLnRyaW0oKTtcbiAgfVxuICBjbGVhblVwQ2xhc3NOYW1lKCkge1xuICAgIHRoaXMucm9vdEVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5yb290RWxlbWVudC5jbGFzc05hbWUucmVwbGFjZSgvbGVuaXMoLVxcdyspPy9nLCBcIlwiKS50cmltKCk7XG4gIH1cbn07XG5leHBvcnQge1xuICBMZW5pcyBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVuaXMubWpzLm1hcCJdLCJuYW1lcyI6WyJ2ZXJzaW9uIiwiY2xhbXAiLCJtaW4iLCJpbnB1dCIsIm1heCIsIk1hdGgiLCJsZXJwIiwieCIsInkiLCJ0IiwiZGFtcCIsImxhbWJkYSIsImRlbHRhVGltZSIsImV4cCIsIm1vZHVsbyIsIm4iLCJkIiwiQW5pbWF0ZSIsImFkdmFuY2UiLCJpc1J1bm5pbmciLCJjb21wbGV0ZWQiLCJkdXJhdGlvbiIsImVhc2luZyIsImN1cnJlbnRUaW1lIiwibGluZWFyUHJvZ3Jlc3MiLCJlYXNlZFByb2dyZXNzIiwidmFsdWUiLCJmcm9tIiwidG8iLCJyb3VuZCIsInN0b3AiLCJvblVwZGF0ZSIsImZyb21UbyIsImxlcnAyIiwib25TdGFydCIsImRlYm91bmNlIiwiY2FsbGJhY2siLCJkZWxheSIsInRpbWVyIiwiYXJncyIsImNvbnRleHQiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiYXBwbHkiLCJEaW1lbnNpb25zIiwiY29uc3RydWN0b3IiLCJ3cmFwcGVyIiwiY29udGVudCIsImF1dG9SZXNpemUiLCJkZWJvdW5jZVZhbHVlIiwid2lkdGgiLCJoZWlnaHQiLCJzY3JvbGxIZWlnaHQiLCJzY3JvbGxXaWR0aCIsInJlc2l6ZSIsIm9uV3JhcHBlclJlc2l6ZSIsIm9uQ29udGVudFJlc2l6ZSIsIldpbmRvdyIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiZGVib3VuY2VkUmVzaXplIiwiYWRkRXZlbnRMaXN0ZW5lciIsIndyYXBwZXJSZXNpemVPYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZSIsImNvbnRlbnRSZXNpemVPYnNlcnZlciIsImRlc3Ryb3kiLCJkaXNjb25uZWN0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImxpbWl0IiwiRW1pdHRlciIsImVtaXQiLCJldmVudCIsImNhbGxiYWNrcyIsImV2ZW50cyIsImkiLCJsZW5ndGgiLCJvbiIsImNiIiwicHVzaCIsImZpbHRlciIsIm9mZiIsIkxJTkVfSEVJR0hUIiwibGlzdGVuZXJPcHRpb25zIiwicGFzc2l2ZSIsIlZpcnR1YWxTY3JvbGwiLCJlbGVtZW50Iiwib3B0aW9ucyIsIndoZWVsTXVsdGlwbGllciIsInRvdWNoTXVsdGlwbGllciIsInRvdWNoU3RhcnQiLCJsYXN0RGVsdGEiLCJlbWl0dGVyIiwib25Ub3VjaFN0YXJ0IiwiY2xpZW50WCIsImNsaWVudFkiLCJ0YXJnZXRUb3VjaGVzIiwiZGVsdGFYIiwiZGVsdGFZIiwib25Ub3VjaE1vdmUiLCJvblRvdWNoRW5kIiwib25XaGVlbCIsImRlbHRhTW9kZSIsIm11bHRpcGxpZXJYIiwibXVsdGlwbGllclkiLCJvbldpbmRvd1Jlc2l6ZSIsImRlZmF1bHRFYXNpbmciLCJwb3ciLCJMZW5pcyIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZXZlbnRzVGFyZ2V0Iiwic21vb3RoV2hlZWwiLCJzeW5jVG91Y2giLCJzeW5jVG91Y2hMZXJwIiwidG91Y2hJbmVydGlhRXhwb25lbnQiLCJpbmZpbml0ZSIsIm9yaWVudGF0aW9uIiwiZ2VzdHVyZU9yaWVudGF0aW9uIiwicHJldmVudCIsInZpcnR1YWxTY3JvbGwiLCJvdmVyc2Nyb2xsIiwiYXV0b1JhZiIsImFuY2hvcnMiLCJhdXRvVG9nZ2xlIiwiYWxsb3dOZXN0ZWRTY3JvbGwiLCJfX2V4cGVyaW1lbnRhbF9fbmFpdmVEaW1lbnNpb25zIiwiX2lzU2Nyb2xsaW5nIiwiX2lzU3RvcHBlZCIsIl9pc0xvY2tlZCIsIl9wcmV2ZW50TmV4dE5hdGl2ZVNjcm9sbEV2ZW50IiwiX3Jlc2V0VmVsb2NpdHlUaW1lb3V0IiwiX19yYWZJRCIsInRpbWUiLCJ1c2VyRGF0YSIsImxhc3RWZWxvY2l0eSIsInZlbG9jaXR5IiwiZGlyZWN0aW9uIiwiYW5pbWF0ZSIsIm9uU2Nyb2xsRW5kIiwiZSIsIkN1c3RvbUV2ZW50IiwiaXNTY3JvbGxpbmciLCJzdG9wUHJvcGFnYXRpb24iLCJkaXNwYXRjaFNjcm9sbGVuZEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImJ1YmJsZXMiLCJkZXRhaWwiLCJsZW5pc1Njcm9sbEVuZCIsIm9uVHJhbnNpdGlvbkVuZCIsInByb3BlcnR5TmFtZSIsImluY2x1ZGVzIiwiY2hlY2tPdmVyZmxvdyIsIm9uQ2xpY2siLCJwYXRoIiwiY29tcG9zZWRQYXRoIiwiYW5jaG9yIiwiZmluZCIsIm5vZGUiLCJIVE1MQW5jaG9yRWxlbWVudCIsImdldEF0dHJpYnV0ZSIsImhyZWYiLCJ0YXJnZXQiLCJzcGxpdCIsInNjcm9sbFRvIiwib25Qb2ludGVyRG93biIsImJ1dHRvbiIsInJlc2V0Iiwib25WaXJ0dWFsU2Nyb2xsIiwiZGF0YSIsImN0cmxLZXkiLCJsZW5pc1N0b3BQcm9wYWdhdGlvbiIsImlzVG91Y2giLCJ0eXBlIiwiaXNXaGVlbCIsImlzVG91Y2hpbmciLCJpc0NsaWNrT3JUYXAiLCJpc1RhcFRvU3RvcCIsImlzU3RvcHBlZCIsImlzTG9ja2VkIiwiaXNVbmtub3duR2VzdHVyZSIsInNsaWNlIiwiaW5kZXhPZiIsInJvb3RFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJjaGVja05lc3RlZFNjcm9sbCIsImNhbmNlbGFibGUiLCJwcmV2ZW50RGVmYXVsdCIsImlzU21vb3RoIiwiZGVsdGEiLCJhYnMiLCJhbmltYXRlZFNjcm9sbCIsImlzU3luY1RvdWNoIiwiaXNUb3VjaEVuZCIsImhhc1RvdWNoSW5lcnRpYSIsInNpZ24iLCJ0YXJnZXRTY3JvbGwiLCJwcm9ncmFtbWF0aWMiLCJvbk5hdGl2ZVNjcm9sbCIsImxhc3RTY3JvbGwiLCJhY3R1YWxTY3JvbGwiLCJyYWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJsZW5pc1ZlcnNpb24iLCJkaW1lbnNpb25zIiwidXBkYXRlQ2xhc3NOYW1lIiwiY2FwdHVyZSIsImNsZWFuVXBDbGFzc05hbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIm92ZXJmbG93IiwicHJvcGVydHkiLCJpc0hvcml6b250YWwiLCJnZXRDb21wdXRlZFN0eWxlIiwiaW50ZXJuYWxTdG9wIiwiaW50ZXJuYWxTdGFydCIsInNldFNjcm9sbCIsInNjcm9sbCIsImxlZnQiLCJiZWhhdmlvciIsInRvcCIsInN0YXJ0Iiwic3R5bGUiLCJyZW1vdmVQcm9wZXJ0eSIsInNldFByb3BlcnR5Iiwib2Zmc2V0IiwiaW1tZWRpYXRlIiwibG9jayIsIm9uQ29tcGxldGUiLCJmb3JjZSIsInF1ZXJ5U2VsZWN0b3IiLCJjb25zb2xlIiwid2FybiIsIm5vZGVUeXBlIiwid3JhcHBlclJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJyZWN0IiwiZGlzdGFuY2UiLCJwcmV2ZW50TmV4dE5hdGl2ZVNjcm9sbEV2ZW50IiwiRGF0ZSIsIm5vdyIsImNhY2hlIiwiX2xlbmlzIiwiaGFzT3ZlcmZsb3dYIiwiaGFzT3ZlcmZsb3dZIiwiaXNTY3JvbGxhYmxlWCIsImlzU2Nyb2xsYWJsZVkiLCJjb21wdXRlZFN0eWxlIiwib3ZlcmZsb3dYU3RyaW5nIiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZU3RyaW5nIiwib3ZlcmZsb3dZIiwiaXNTY3JvbGxpbmdYIiwiaXNTY3JvbGxpbmdZIiwibWF4U2Nyb2xsIiwiaGFzT3ZlcmZsb3ciLCJpc1Njcm9sbGFibGUiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwid2lsbFNjcm9sbCIsInNjcm9sbFgiLCJzY3JvbGxZIiwicHJvZ3Jlc3MiLCJjbGFzc05hbWUiLCJ0cmltIiwicmVwbGFjZSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/lenis/dist/lenis.mjs\n");

/***/ })

};
;